<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JEE6 | Steve Hostettler]]></title>
  <link href="http://hostettler.github.io/blog/categories/jee6/atom.xml" rel="self"/>
  <link href="http://hostettler.github.io/"/>
  <updated>2014-10-12T17:43:30+02:00</updated>
  <id>http://hostettler.github.io/</id>
  <author>
    <name><![CDATA[Steve Hostettler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Context Dependency Injection and the Rich Object Model]]></title>
    <link href="http://hostettler.github.io/blog/2012/12/05/servicelocator/"/>
    <updated>2012-12-05T06:59:00+01:00</updated>
    <id>http://hostettler.github.io/blog/2012/12/05/servicelocator</id>
    <content type="html"><![CDATA[<p>[Rich object model] vs [anemic object model] is long running debate. While the latter encourages to use simple and stupid objects with little or no business in them, the rich object model advocates for a clean object design with inheritance, polymorphism and so on.
The anemic object model is very popular among JEE partitioners because, in the past, the specification did not provide any mean to invoke services in business objects. Therefore, the anemic pattern uses so called "managers" that maintain references to other "managers". A direct benefit is the clear separation of concerns between the different kind of objects. Basically, it splits processing and data. As this is anti-object oriented, the abstract design of such system is often very different from the actual implementation.</p>

<h2>The portfolio example</h2>

<p>As example, let us take a portfolio that contains a set of financial position. A financial position can be either a set of stock, or an amount in a given currency. To evaluate the actual portfolio value, we go through the positions and for each of them we ask the current quote for stock to the service <code>QuoteService</code> or the current value of a given currency to the <code>CurrencyService</code>.
The next figure presents the "ideal" design.</p>

<p><span class='caption-wrapper center'><img class='caption' src='/figures/portfolio-business.png' width='' height='' alt='An object oriented class diagram of the Portfolio management component.' title='An object oriented class diagram of the Portfolio management component.'><span class='caption-text'>An object oriented class diagram of the Portfolio management component.</span></span></p>

<p>To achieve this, one need to access services from within business objects. Since EJB 3.1,  Context and Dependency Injection (CDI) provides such a mechanism via the <code>@Inject</code> annotation. The only requirement is that the object that requires the service as well as the service to inject are so called "managed beans". The trick is that not all objects are meant to be managed. Furthermore, having managed lists of object is very tricky to say the least. Fortunately, the EJB 3.1 and more specifically the CDI 1.0 specification provide a way to solve this.
In CDI, the main component is the bean manager. This manager keeps track of the beans to inject via @Inject and other means. Instead of relying on annotations to provide injection, it is possible to use the good old Service Locator pattern. CDI 1.0 exposes the bean manager on JNDI with the name <code>java:comp/BeanManager</code>.</p>

<p>```java
public class ServiceLocator {</p>

<pre><code>@SuppressWarnings("unchecked")
public static &lt;T&gt; T getInstance(final Class&lt;T&gt; type) {
    T result = null;
    try {

        //Access to the current context.
        InitialContext ctx = new InitialContext();
        //Resolve the bean manager
        BeanManager manager = (BeanManager) ctx.lookup("java:comp/BeanManager");
        //Retrieve all beans of that type
        Set&lt;Bean&lt;?&gt;&gt; beans = manager.getBeans(type);
        Bean&lt;T&gt; bean = (Bean&lt;T&gt;) manager.resolve(beans);
        if (bean != null) {
            CreationalContext&lt;T&gt; context = manager
                    .createCreationalContext(bean);
            if (context != null) {
                result = (T) manager.getReference(bean, type, context);
            }
        }
    } catch (NamingException e) {
        throw new RuntimeException(e);
    }
    return result;
}
</code></pre>

<p>}
```</p>

<p>The client code is very simple. It consists in calling the <code>ServiceLocator</code>with the desired interface.
For the sake of clarity, I did not show the ServiceLocator that takes a qualifier in addition to the interface. To add this feature, look at the <code>getBeans(Type beanType, Annotation... qualifiers)</code> method.</p>

<p>```java</p>

<p>public class StockPos {</p>

<pre><code>private Long qty;
private String stockId;

Double evaluate() {
    StockQuoteService sqs = ServiceLocator.getInstance(StockQuoteService.class);
    return qty * sqs.getQuoteValue(stockId);
}
</code></pre>

<p>}
```</p>

<p>Similarly, here is the code of the <code>CurrencyPos</code> object.</p>

<p>```java</p>

<p>public class CurrencyPos {</p>

<pre><code>private Double amount;
private String currencyId;

Double evaluate() {
    CurrencyQuoteService sqs = ServiceLocator.getInstance(CurrencyQuoteService.class);
    return amount * sqs.getQuoteValue(stockId);
}
</code></pre>

<p>}
```</p>

<h2>Some thoughts on the Demeter law</h2>

<p>Let me be clear, I do <strong>not</strong> recommend this approach everywhere. It is very important to not mix the objects responsabilities. Furthermore,
in order to respect the Demeter law, a business must <strong>not</strong> directly call something outside of the current component. Calls to other components are always to be done through so-called consumers to have clear components boundaries.
For instance, putting to much intelligence in JPA entities that can be detached and serialized may cause problems on the client side.</p>

<h2>Conclusion</h2>

<p>In this post, I showed a solution to consume services that are exposed via the CDI BeanManager. These services can be pure POJOs or EJBs.
Nevertheless, this approach must be used with great care as it can blur the components boundaries and responsabilities.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multi-Tenancy with EJB 3.1 and JPA 2.0]]></title>
    <link href="http://hostettler.github.io/blog/2012/11/20/multi-tenancy/"/>
    <updated>2012-11-20T05:18:00+01:00</updated>
    <id>http://hostettler.github.io/blog/2012/11/20/multi-tenancy</id>
    <content type="html"><![CDATA[<p>Multi-tenancy is a recurrent non functional requirement. Indeed, many important IT-systems are meant to be shared among multiple tenants. The data are often distributed over several databases or schemas. This, for different reasons:</p>

<ul>
<li>Security: The data belong to different customers and some level of isolation is required;</li>
<li>Performances: Distributing the data over multiple systems may help to master performance issues;</li>
<li>Legacy: Sometimes, old and new systems must cohabit for a (long) time;</li>
<li>Maintenability: A database or a schema can be updated without putting the rest of the application at risk.</li>
</ul>


<p>Although data are distributed, the application code should remain tenant agnostic. Furthermore, choosing between the different tenants is often made at runtime based on credentials (e.g. user Joe has access to customer AAAA while user Jane sees data of customer BBB). <a href="/https://blogs.oracle.com/arungupta/entry/java_ee_7_key_features">Java EE 7 will address this problem and much more</a>, but in the mean time here is the way that I use to address this problematic using EJB 3.1 and JPA 2.0</p>

<h2>Overall architecture</h2>

<p>First, let me start with the overall architecture as described below.</p>

<p><span class='caption-wrapper center'><img class='caption' src='/figures/multi-tenancy-architecture.png' width='' height='' alt='Multi-tenancy architecture with serveral datasources' title='Multi-tenancy architecture with serveral datasources'><span class='caption-text'>Multi-tenancy architecture with serveral datasources</span></span></p>

<p>In the above figure, the database is organized in schemas, with one application server datasource (DS) per schema and one persistence unit (PU) per datasource.
It is also possible to use only one datasoure and to discriminate between schemas by setting the <code>&lt;property name="openjpa.jdbc.Schema" value="TenantX" /&gt;</code> property for each persistence unit (PU). This sets the default schema for the PU.
Here is a <code>persistence.xml</code> file that provides one persistence unit per tenant.</p>

<p>The following code has been tested for Open-JPA but there is nothing specific to this implementation outside of the <code>&lt;provider&gt;</code>tag in the <code>persistence.xml</code>file.</p>

<p>```xml
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;persistence version="2.0"</p>

<pre><code>xmlns="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"&gt;

&lt;persistence-unit name="Tenant1" transaction-type="JTA"&gt;
    &lt;provider&gt;
        org.apache.openjpa.persistence.PersistenceProviderImpl
    &lt;/provider&gt;
    &lt;jta-data-source&gt;jdbc/Tenant1_DS&lt;/jta-data-source&gt;
    &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt;
&lt;/persistence-unit&gt;


&lt;persistence-unit name="Tenant2" transaction-type="JTA"&gt;
    &lt;provider&gt;
        org.apache.openjpa.persistence.PersistenceProviderImpl
    &lt;/provider&gt;
    &lt;jta-data-source&gt;jdbc/Tenant2_DS&lt;/jta-data-source&gt;
    &lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes&gt;
&lt;/persistence-unit&gt;
</code></pre>

<p></persistence>
```</p>

<p>The basic idea is that, instead of using <code>@PersistenceContext</code>, we inject our "own" multi tenant entity manager wraper.
Then, at runtime, the multi-tenant entity manager loads the persistence context that corresponds to the current user context from JNDI.
Please note that this only works for JTA-based persistence-units. Otherwise, the persistence context is not container-basd and therefore not exposed to JNDI. Moreover, without JTA, we loose container based transaction demarcation.</p>

<p>Let us first start with the client code. In other words, how to use the Multi-Tenant Entity manager.</p>

<h2>Client Code</h2>

<p>Here is the client code. In order to preserve thread-safety and transactionality, Data access objects are EJBs (<code>@Stateless</code>, <code>@Stateful</code>, <code>@Singleton</code>). The presented solution uses an entity manager that is wrapped and then injected using <code>@Inject</code> or <code>@EJB</code>.  Thread-safety, transactionnality and performances are guaranted by the <code>EJB 3.1</code> and <code>JPA 2.0</code> specification as explained in the section <code>Thread-safety and Transactionality</code>. As shown below, the <code>MultiTenancyWrapper</code> delegates to a real entity manager and implements the <code>EntityManager</code> interface. Therefore, its use is very similar to a normal <code>EntityManager</code> injected via <code>@PersistenceContext</code>.</p>

<p>```java
@Stateless
public class MyEJB implements MyEJBLocal {</p>

<pre><code>@Inject
private MultiTenancyWrapper emWrapper;

@TransactionAttribute(TransactionAttributeType.REQUIRED)
public void doSomething() {
    emWrapper.findAll(...);
}
</code></pre>

<p>}
```</p>

<h2>The Multi-Tenant EntityManager EJB</h2>

<p>The <code>MultiTenanEntityManagertWrapper</code> simply wraps the entity manager that corresponds to the current user context. The trick is to configure it as an EJB in order to get the xml configuration feature via <code>ejb-jar.xml</code>. Another alternative would be to use the <code>@PersistenceContexts</code> and <code>@PersistenceContext</code> annotations. The main drawback being that, for each new tenant, not only the <code>persistence.xml</code> and <code>ejb-jar.xml</code> must be changed but also the <code>Java</code> code.</p>

<p>The JNDI context that is linked to the current request is injected in the <code>MultiTenantEntityManager</code> using the <code>@Resource</code>annotation.
As there is no creation of a new <code>InitialContext</code> the overhead is not significant. Actually, the <code>@PersistentContext</code> annotation does the exact same thing except that it is not specific to the user context. The <code>MultiTenanEntityManagertWrapper</code> implements the delegate pattern. This allows to use it (almost) transparently in client code.
The main difference being the use of <code>@Inject</code> or <code>@EJB</code> over <code>@PersistenceContext</code> in the client code.</p>

<p>Using the session context that is specific to the caller bean (and thus the caller request/session) enables transparent support for thread-safety, security and transactionality.</p>

<p>```java
package ejb;</p>

<p>import javax.persistence.EntityManager;</p>

<p>public interface MultiTenanEntityManagertWrapper extends EntityManager {</p>

<p>}
```</p>

<p>The method <code>getMultiTenantEntityManager</code> of the <code>MultiTenanEntityManagertWrapperImpl</code> extracts the <code>EntityManager</code> that corresponds to the current request from JNDI (we will see later how it has been put there). To that end, the method <code>getMultiTenantEntityManager</code>first extracts the prinipal from the current EJB context (<code>SessionContext</code>). After what, the tenant that corresponds to the current user is used to obtain the JNDI name of the corresponding entity manager. <code>MultiTenanEntityManagertWrapperImpl</code> simple delegates every call to the this Request specific <code>EntityManager</code>.</p>

<p>```java</p>

<p>@Stateless
public class MultiTenanEntityManagertWrapperImpl implements MultiTenanEntityManagertWrapper {</p>

<pre><code>private static final String JNDI_ENV = "java:comp/env/persistence/";

@Resource
SessionContext context;


private EntityManager getMultiTenantEntityManager() {
    //Extract the name of the current user.
    Principal p = context.getCallerPrincipal();

    //Lookup the tenant name for the current user
    //This is application specific
    Users u = Users.getUser(p.getName());

    //Produces either TENANT1 or TENANT2        
    String tenantName = u.getSite().toString();

    String jndiName = new StringBuffer(JNDI_ENV).append(tenantName).toString();
    //Lookup the entity manager
    EntityManager manager = (EntityManager) context.lookup(jndiName);

    if (manager == null) {
        throw new RuntimeException("Tenant unknown");
    }
    return manager;
}


//The delegates
@Override
public void persist(Object entity) {
    getMultiTenantEntityManager().persist(entity);
}


@Override
public &lt;T&gt; T merge(T entity) {
    return getMultiTenantEntityManager().merge(entity);
}


@Override
public void remove(Object entity) {
    getMultiTenantEntityManager().remove(entity);
}

    ...
</code></pre>

<p>}
```</p>

<p>Now let us see how to put the entity manager references in JNDI.
In order to avoid a lot of annotations (one per tenant) and therefore to be able to handle a huge number of tenans, I propose to use the <code>ejb-jar.xml</code> file to configure the EJB intead of the <code>PersistenceContext</code> annotation. The <code>MultiTenantEntityWrapper</code>EJB is configured as a stateless EJB. Ther persistence contexts are simply exposed to JNDI with the following pattern: <code>java:comp/env/persistence/TENANTX</code>. For more information please look at the EJB 3.1 specification chapter 16.11.1.</p>

<p><code>&lt;persistence-unit-name&gt;Tenant1&lt;/persistence-unit-name&gt;</code> is the name of the PU as defined in the <code>persistence.xml</code> file. <code>&lt;persistence-context-ref-name&gt;persistence/TENANT1&lt;/persistence-context-ref-name&gt;</code>defines the name of the entity manager that is exposed via JNDI.</p>

<p>```xml
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;ejb-jar xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:ejb="http://java.sun.com/xml/ns/javaee/ejb-jar_3_0.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd" version="3.1"></p>

<pre><code>&lt;enterprise-beans&gt;
    &lt;session&gt;
        &lt;ejb-name&gt;MultiTenantEntityWrapper&lt;/ejb-name&gt;   
        &lt;ejb-class&gt;ejb.MultiTenantWrapperImpl&lt;/ejb-class&gt;
        &lt;session-type&gt;Stateless&lt;/session-type&gt;

        &lt;!-- Persistece contexts --&gt;
        &lt;persistence-context-ref&gt;
            &lt;description&gt;Tenant 1&lt;/description&gt;             
            &lt;persistence-context-ref-name&gt;persistence/TENANT1&lt;/persistence-context-ref-name&gt;        
            &lt;persistence-unit-name&gt;Tenant1&lt;/persistence-unit-name&gt;
            &lt;persistence-context-type&gt;Transaction&lt;/persistence-context-type&gt;
        &lt;/persistence-context-ref&gt;

        &lt;persistence-context-ref&gt;
            &lt;description&gt;Tenant 2&lt;/description&gt;             
            &lt;persistence-context-ref-name&gt;persistence/TENANT2&lt;/persistence-context-ref-name&gt;        
            &lt;persistence-unit-name&gt;Tenant2&lt;/persistence-unit-name&gt;
            &lt;persistence-context-type&gt;Transaction&lt;/persistence-context-type&gt;                
        &lt;/persistence-context-ref&gt;

    &lt;/session&gt;
&lt;/enterprise-beans&gt;
</code></pre>

<p>&lt;/ejb-jar>
```</p>

<h2>Thread-safety and Transactionality</h2>

<p>As this is compliant with both the EJB 3.1 and JPA 2.0 specification, thread-safety and transactionnaly are guaranteed by the container. For more details please look at the EJB 3.1 specification
at chapters 16.10, 16.11 and the JPA 2.0 specification at chapter 7.6. Of course, the wrapper has to be an EJB in order to have access to the current JNDI context without having to create it.
Furthermore, because the <code>EntityManager</code>is not <code>per se</code> thread-safe (JPA 2.0, chapter 7.2), the serialization of the invokations that is provided by the container for EJBs is essential the thread-safety aspect (EJB 3.1, chapter 4.10.13).</p>

<h2>Conclusion</h2>

<p>In this post, I showed how to leverage EJB 3.1 and JPA 2.0 standard features to provide multi-tenancy. The presented approach is thead-safe, it preserves transactionaly and does not induce
a significant overhead.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About Sessions, Conversations, and the Garbage Collector]]></title>
    <link href="http://hostettler.github.io/blog/2012/06/10/Sessions-GC-Conversations/"/>
    <updated>2012-06-10T18:51:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/06/10/Sessions-GC-Conversations</id>
    <content type="html"><![CDATA[<p>A couple of days ago, I had a discussion with a developer about the notion of web conversation.
More precisely, about its utility. During this discussion, we ran into some basic misconceptions
that, IMHO, no web developer must do. Conversation (or flows) are good features of the recent
frameworks (Spring, JSF) because they allow to save information across several user requests without
putting them into the session. For instance, this can be very useful for wizards. Putting these
information into the session asks for manual maintenance, and in particular for manual collection.
This is usual error prone and should be avoided. The problem being that the user rarely logs out
before closing the browser. Thus, <code>HttpSession.invalidate()</code> does not get a chance to be called
and the session remains active until the timeout occurs (usually 20 minutes later).</p>

<p>The person I was talking with, though that it is not necessary to care about that. In his view,
the garbage collector will take care of this and that it can be forced. We discuss the matter a bit
deeper and here are some myths that I think must be rebutted.</p>

<h2>First assumption: I can force the garbage collection</h2>

<p>This is not true, actually according to the Java documentation:
<code>
Calling the gc method suggests that the Java Virtual Machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse. When control returns from the method call, the Java Virtual Machine has made a best effort to reclaim space from all discarded objects.
</code></p>

<p><code>System.gc()</code> <strong>suggests</strong> the garbage collection, it does not enforce it. This signals that you
would like the garbage collector to do its job, but there is no guarantee whatsoever. It is only
possible to enforce garbage collection by writing your own garbage collector, but you cannot expect
all garbage collectors of all the possible VM to act similarly. Therefore, relying on this
assumption is not portable.</p>

<h2>Second assumption: If I close the browser the session and its objects are collected</h2>

<p>Even If it would be possible to enforce the garbage collection, it is of no use as long as there
remains a single reference to the objects to collect. Again, this is absolutely not the case.
Remember that closing the browser does not mean anything to the server. It would, in theory possible
to imagine something with an ajax call that traps the close event of the browser and does a
<code>HttpSession.invalidate()</code> . This is quite complex to do in a cross-browser manner and gives no
guarantee. Therefore, the data attached to the session will be kept in memory until the session
timeout. This is precisely the beauty of conversation scopes, the developer just tells when the
conversation starts and when it ends. Usually, user do not stop in the middle of a conversation,
they tend to finish it. At least, more often that they click on logout.</p>

<h2>Third assumption: Anyway this does not represent a huge amount of memory.</h2>

<p>Let us take a simple example: a standard business application that, at some point in the business
process, requires a tree for shop selection. This kind of interactions requires several client-server
communications and therefore several requests. A temptation would be to put the tree in the session
scope. Let us say that 10,000 (logical) users log into the application, for instance from 09:00 am to 09:30
am. If each session requires 100 KB (trees are huge even with lazy loading), we end up with 1G memory(only for the tree).
As most of the users do not click on logout, you rely on the timeout to free these objects.</p>

<h2>Conclusion</h2>

<p>Using request scope of conversation scope over session scope is a good practice as it frees you
from managing the garbage collection. The code is therefore cleaner and more efficient.
This can be done with JSF's <code>@ConversationScoped</code> or with Spring Webflow's <code>Conversation</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object-XML Mapping with JAXB & MOXy]]></title>
    <link href="http://hostettler.github.io/blog/2012/05/24/moxy/"/>
    <updated>2012-05-24T19:17:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/05/24/moxy</id>
    <content type="html"><![CDATA[<p>Object-Relational mapping is around for a while and its last incarnation, JPA 2.0, is easy to use
yet powerful and adapted to most of the real-life situations. A problem that is similar to
Object-Relational mapping (ORM) is Object-XML mapping (OXM). More precisely, it aims at mapping XML
schemas to JAVA classes. JAXB (JSR 222) specifies how to maps classes to xml schemas.
In this post, I demonstrate the ease of use of this approach using <a href="http://www.eclipse.org/eclipselink/moxy.php">MOXy</a>. MOXy is the Eclipse implementation of JAXB and I found it really easy to use.</p>

<p>As always let us first look at the Maven dependencies:
```xml Maven dependencies for using MOXy
<repositories></p>

<pre><code>    &lt;repository&gt;
        &lt;id&gt;EclipseLink Repo&lt;/id&gt;
        &lt;name&gt;EclipseLink Repository&lt;/name&gt;
        &lt;url&gt;http://download.eclipse.org/rt/eclipselink/maven.repo&lt;/url&gt;
    &lt;/repository&gt;
</code></pre>

<p></repositories></p>

<p><dependencies></p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;
    &lt;artifactId&gt;eclipselink&lt;/artifactId&gt;
    &lt;version&gt;2.3.2&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
...
</code></pre>

<p></dependencies>  <br/>
```</p>

<p>Eclipse-link provides an implementation for JAXB. The rest is in the JEE 6 SDK.</p>

<p>In this post I only consider the case in which we have control over the schema.
In this case, it is sufficient to annotate the fields and the classes you want to marshall to XML.
Let us use the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project that can be found on Google
Code. The following snippet shows a simple model that represents a student.</p>

<p>As you can see there are few annotations. The first one <code>@XmlRootElement</code> simply declares what the  root element is. The second annotation specifies the mapping policy. We will come back on that later. The fields are either not annotated or annotated with @Transient. In the first case, they
are marshaled if not null and in the second they are simply ignored. The only tricky part is that transient fields (in the Java sense) are ignored. For instance, this is the case of the <code>gender</code> property.</p>

<p>```java A simple mapping from object to XML
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class Student implements Serializable {</p>

<pre><code>private Long id;

private String lastName;

private String firstName;

private Date birthDate;

@XmlTransient
private PhoneNumber phoneNumber;

private transient Gender gender;

@XmlTransient
private Address address;

@XmlTransient
private List&lt;Grade&gt; grades;

...

@XmlTransient
private Badge badge;
...
</code></pre>

<p>}
```</p>

<p>Let us now test the mapping. The code below, creates a new <code>Student</code> and fills the associated
fields. The second part of the snippet marshals the object into XML and streams it to <code>System.out</code>.</p>

<p>```java Creation of student and its marshaling to XML</p>

<pre><code>Student student = new Student("Lion Hearth", "Richard", new Date());
Address address = new Address();
address.setCity("Carouge");
address.setNumber("7");
address.setPostalCode("1227");
address.setStreet("Drize");
student.setAddress(address);
Badge b = new Badge();
b.setSecurityLevel(30L);
b.setStudent(student);
student.setBadge(b);
student.setPhoneNumber(new PhoneNumber(0, 0, 0));
for (Discipline d : Discipline.values()) {
    Grade g = new Grade(d, 10);
    student.getGrades().add(g);
}

JAXBContext jaxbContext = JAXBContext.newInstance(Student.class);       
Marshaller marshaller = jaxbContext.createMarshaller();
marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
marshaller.marshal(student, System.out);
</code></pre>

<p>```</p>

<p>Finally, the result looks like the XML below. As you can see, it is pretty easy and straight-forward
to produce XML from a Class description. Most of the fields that have been populated are not
marshaled to XML. This is due to the <code>@XMLTransient</code> annotation that tells JAXB not to consider
them for output.</p>

<p>```xml Marshaled version of the previous Student object.
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student></p>

<pre><code>&lt;lastName&gt;Lion Hearth&lt;/lastName&gt;
&lt;firstName&gt;Richard&lt;/firstName&gt;
&lt;birthDate&gt;2012-06-04T11:12:34.751+02:00&lt;/birthDate&gt;
</code></pre>

<p></student>
```</p>

<h3>Mapping Overview</h3>

<p>The previous example was as simple as possible. Obviously, sometimes it is important to be able to
tweak the mapping. Let us look at some simple mapping options.</p>

<h4>Element naming</h4>

<p>The default mapping rule is to use the field name as XML element name. This policy can be overridden
by the <code>@XmlElement(name = ...)</code> annotation. Applying the annotation <code>@XmlElement(name="last_name")</code> on the <code>lastName</code> field of the previous example would result in:
```xml Example of named element
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student></p>

<pre><code>&lt;last_name&gt;Lion Hearth&lt;/last_name&gt;
&lt;firstName&gt;Richard&lt;/firstName&gt;
&lt;birthDate&gt;2012-06-04T11:12:34.751+02:00&lt;/birthDate&gt;
</code></pre>

<p></student>
```</p>

<h4>Attributes vs elements</h4>

<p>By default fields are marshaled as XML elements. It is possible to ask JAXB to transform them to
XML attributes by using <code>@XmlAttribute</code> annotation. Putting <code>@XmlAttribute</code> on the <code>lastName</code>
field of the previous example would produce the following XML:
```xml Example of using an attribute instead of an element
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student lastName="Lion Hearth"></p>

<pre><code>&lt;firstName&gt;Richard&lt;/firstName&gt;
&lt;birthDate&gt;2012-06-04T11:12:34.751+02:00&lt;/birthDate&gt;
</code></pre>

<p></student>
```
Please note that as for an element, the attribute name can be customized.</p>

<h4>Mapping strategy</h4>

<p>As mentioned before, the default mapping strategy is declared by using the <code>@XmlAccessorType(XmlAccessType.*)</code> annotation.</p>

<p>There exists four mapping policies. For more details, look at the <a href="http://docs.oracle.com/javaee/6/api/javax/xml/bind/annotation/XmlAccessType.html">Javadoc</a> for <code>XmlAccessorType</code>. Here is an excerpt
from the Java doc.</p>

<ol>
<li><code>FIELD</code>: Every non static, non transient field in a JAXB-bound class will be automatically bound to XML, unless annotated by XmlTransient.</li>
<li><code>NONE</code>: None of the fields or properties is bound to XML unless they are specifically annotated with some of the JAXB annotations.</li>
<li><code>PROPERTY</code>: Every getter/setter pair in a JAXB-bound class will be automatically bound to XML, unless annotated by XmlTransient.</li>
<li><code>PUBLIC_MEMBER</code>: Every public getter/setter pair and every public field will be automatically bound to XML, unless annotated by XmlTransient.</li>
</ol>


<h4>Name spaces</h4>

<p>An important aspect of XML is its modularity. In particular, namespaces bring a nice way to organize
the XML and the schemas. Namespaces can be specified at different levels. For more details look at the <a href="http://wiki.eclipse.org/EclipseLink/UserGuide/MOXy/Type_Level/Setting_Up_Namespace_Information">MOXy documentation</a>. For now, it is sufficient to known that the <code>@XmlType</code>, <code>@XmlElement</code>, and <code>@XmlAttribute</code> annotations support a namespace attribute.</p>

<h3>One to one mapping</h3>

<p>Now that we have mapped simple field, let us look at more complex mappings. First, a 1-1 mapping.
The following example maps an address.</p>

<p>```java Add a one to one mapping
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class Student implements Serializable {</p>

<pre><code>...

private Address address;
</code></pre>

<p>}
<code>
To that end, it is sufficient to add the following annotations to the Address type.
</code>
@XmlRootElement(name = "address")
@XmlAccessorType(XmlAccessType.FIELD)
public class Address implements Serializable {</p>

<pre><code>...
/** house number. */
private String number;

/** the name of the street. */
private String street;

/** the city name. */
private String city;

/** the postal code. */
private String postalCode;
...
</code></pre>

<p>}
```</p>

<p>And the rest is handled by JAXB to produce the following result.</p>

<p>```xml
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student></p>

<pre><code>...
&lt;address&gt;
    &lt;number&gt;7&lt;/number&gt;
    &lt;street&gt;Drize&lt;/street&gt;
    &lt;city&gt;Carouge&lt;/city&gt;
    &lt;postalCode&gt;1227&lt;/postalCode&gt;
&lt;/address&gt;
</code></pre>

<p></student>
```</p>

<h4>Bi-directional one to one</h4>

<p>The next example is more tricky. The problem with bi-directional mapping is that they produce
graphs. Of course, since XML are trees, we must avoid cycles. The solution is to annotate the reverse mapping (<code>Student student</code> in this case) with <code>@XMLTransient</code> causing the property to be ignored by JAXB.</p>

<p>```java Add a one to one bidirectional mapping
@XmlRootElement(name = "student")
@XmlAccessorType(XmlAccessType.FIELD)
public class Student implements Serializable {</p>

<pre><code>...

private Badge badge;
</code></pre>

<p>}
```</p>

<p>The following type describes the <code>Badge</code> that has a reverse mapping to <code>Student</code>.
<code>`java Mapping of the type</code>Badge``
@XmlRootElement(name = "badge")
@XmlAccessorType(XmlAccessType.FIELD)
public class Badge implements Serializable {</p>

<pre><code>/** The unique id. */
private Long id;

/** The student's security level. */
@XmlAttribute
private Long securityLevel;

/** The student that owns this badge. */
@XmlTransient
private Student student;
</code></pre>

<p>```
And finally, here is the result.</p>

<p>```xml Result of the bi-directional mapping
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student></p>

<pre><code>...
&lt;badge securityLevel="30"/&gt;
</code></pre>

<p></student>
```</p>

<h3>One to many mapping</h3>

<p>One to many mappings are handled automatically. There is nothing special to do. In our example,
removing the <code>@XmlTransient</code> annotation on the <code>grades</code> property will generate the following output:</p>

<p>```xml One to many example
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student></p>

<pre><code>&lt;last_name&gt;Lion Hearth&lt;/last_name&gt;
&lt;firstName&gt;Richard&lt;/firstName&gt;
&lt;birthDate&gt;2012-06-05T10:57:36.699+02:00&lt;/birthDate&gt;
&lt;phoneNumber&gt;+00-0000-0000&lt;/phoneNumber&gt;
&lt;address&gt;
    &lt;number&gt;7&lt;number&gt;
    &lt;street&gt;Drize&lt;/street&gt;
    &lt;city&gt;Carouge&lt;/city&gt;
    &lt;postalCode&gt;1227&lt;/postalCode&gt;
&lt;/address&gt;
&lt;grades&gt;
    &lt;discipline&gt;MATHEMATICS&lt;/discipline&gt;
    &lt;grade&gt;10&lt;/grade&gt;
&lt;/grades&gt;
&lt;grades&gt;
    &lt;discipline&gt;BIOLOGY&lt;/discipline&gt;
    &lt;grade&gt;10&lt;/grade&gt;
&lt;/grades&gt;
</code></pre>

<p> ...</p>

<pre><code>&lt;badge securityLevel="30"/&gt;
</code></pre>

<p></student>
```</p>

<h2>Custom mapping</h2>

<p>Sometimes, it is difficult to map a given type to a given XML structure. This is the case of the <code>PhoneNumber</code> type in our example. To that end, it is possible to define a <code>XMLJavaTypeAdatper</code>
that will convert XML to object and objects to XML manually. The adapter is not very difficult to implement. It is composed of two methods that respectively unmarshal from XML and marshal to XML.</p>

<p>```java
public class PhoneNumberAdapter extends XmlAdapter&lt;String, PhoneNumber> {</p>

<pre><code>@Override
public PhoneNumber unmarshal(final String value) throws Exception {
    return PhoneNumber.getAsObject((String) value);
}

@Override
public String marshal(final PhoneNumber value) throws Exception {
    return PhoneNumber.getAsString((PhoneNumber) value);
}
</code></pre>

<p>}
<code>
Then, it is required to annotated the property with this adapter:
</code>java Using a custom XML-Object Adapter</p>

<pre><code>...
@XmlJavaTypeAdapter(PhoneNumberAdapter.class)
private PhoneNumber mPhoneNumber;
...
</code></pre>

<p>```</p>

<p>This will produce the following result:
```xml
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student></p>

<pre><code>&lt;last_name&gt;Lion Hearth&lt;/last_name&gt;
&lt;firstName&gt;Richard&lt;/firstName&gt;
&lt;birthDate&gt;2012-06-05T10:57:36.699+02:00&lt;/birthDate&gt;
&lt;phoneNumber&gt;+00-0000-0000&lt;/phoneNumber&gt;
...
</code></pre>

<p></student>  <br/>
```</p>

<h2>What about XML schemas</h2>

<p>As mentioned previously, we assumed that you have total control over the schema. Nevertheless, it can
be useful to be able to produce this schema. This is done by the following snippet.</p>

<p>```java Output the underlying schema
SchemaOutputResolver sor = new SchemaOutputResolver() {</p>

<pre><code>@Override
public Result createOutput(final String namespaceUri,
        final String suggestedFileName) throws IOException {
    Result result = new StreamResult(System.out);
    result.setSystemId("System.out");
    return result;
}
</code></pre>

<p>};
jaxbContext.generateSchema(sor);
```</p>

<h2>Write XML</h2>

<p>Writing XML is fairly easy, just populate the objects that you want to marshal and then
use the following code:
<code>java How to marshal a given object
JAXBContext jaxbContext = JAXBContext.newInstance(Student.class);       
Marshaller marshaller = jaxbContext.createMarshaller();
marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
marshaller.marshal(student, System.out);
</code></p>

<h2>Read XML</h2>

<p>The reverse operation is as easy and straightforward (provided that use the same schema):
<code>java How to unmarshal a given XML file to objects
InputStream stream = StudentOXTest.class.getResourceAsStream("/student.xml");
JAXBContext jaxbContext = JAXBContext.newInstance(Student.class);
Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
Student student = (Student) unmarshaller.unmarshal(stream);
</code></p>

<h2>Conclusion</h2>

<p>We have seen how to use MOXy to map objects to XML. Using JAXB annotations, it is very easy to read and write XML. The examples used in this blog are to be found in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project on <a href="http://code.google.com">Google code hosting</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A JEE6 security interceptor for Tomcat 7]]></title>
    <link href="http://hostettler.github.io/blog/2012/05/02/a-jee6-security-interceptor-for-tomcat-7/"/>
    <updated>2012-05-02T18:23:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/05/02/a-jee6-security-interceptor-for-tomcat-7</id>
    <content type="html"><![CDATA[<p>Security in Java EE is a well-known subject and JAAS, the framework that manages security, is
stable and reliable. Nevertheless, its API is quite low level and not always very convenient. For
that reason, there exist a number of frameworks that have been built on top of JAAS that provide
nice abstractions and convenient tools. This is especially true for the JEE application servers such as <a href="http://glassfish.java.net/">Glassfish</a>, <a href="http://www.jboss.org/">JBoss</a> and the like.</p>

<p>In servlet containers such as <a href="http://tomcat.apache.org/">Tomcat</a> or <a href="http://jetty.codehaus.org/jetty/">Jetty</a> however, only the web components are secured and it is not trivial to secure services and the data access layer. This can be solved by integrating framework such as <a href="http://static.springsource.org/spring-security/site/">Spring Security</a>, <a href="http://shiro.apache.org/">Apache Shiro</a>.</p>

<p>As always it is not always possible to put a new framework or library in place. I will not
discuss whether it is a good or a bad idea to develop a new security mechanism. Nevertheless, a good
rule of thumb is to reuse existing components and not reinvent the wheel ... when possible. If for
let's say licensing reasons, it is not possible: here is a way to provide a simple declarative
authorisation procedure based on JAAS and the JEE6 interceptors. The objective is to propagate the
authorisation to non-web layers such as services or data access layer through a thread-local
variable.</p>

<p>The goal is to be able to write something similar to the following snippet. The idea is to annotate
a method (or a class) with a list of roles that are authorised. If the method executes in a context
in which a user has not enough rights, it raises an exception.</p>

<p>```java Example of a service layer protected by JEE6 interceptor
@Secure(roles = { "user" })
public List<Student> getAll() {</p>

<pre><code>...
</code></pre>

<p>}</p>

<p>@Secure(roles = { "admin" })
public void add(final Student student) {</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<h3>Java Authentication and Authorisation System</h3>

<p>Java Authentication and Authorisation System (JAAS) provides a security infrastructure for JAVA.
Both <strong>authentication</strong> (are you who you pretend to be?) and <strong>authorisation</strong> (are you allowed to do something you would like to do?) are covered. JAAS relies on the concept of principal.
A principal is a particular identity of a user (e.g. social security id, driver licence id, ...).
By default, in JAVA SE, there is no easy way to have the list of roles granted to a given user.
To solve that problem, we need a bean that knows to which role a given Principal is authorised.
This is the role of <code>MyPrincipal</code>.</p>

<p>```java A custom principal that contains the roles
public class MyPrincipal implements Principal, Serializable {</p>

<pre><code>public MyPrincipal(final Principal pPrincipal, final List&lt;String&gt; pRoles) {
    this.principal = pPrincipal;
    this.roles = pRoles;
}
...  
public boolean isUserInRole(final String pRole) {
    return roles.contains(pRole);
}
</code></pre>

<p>}
```</p>

<h3>JEE6 Interceptors</h3>

<p>Since JEE6, a feature called interceptors enables simple
<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect Oriented Programming</a> without
using any specific framework. It works, of course, only on managed classes. Namely, classes that are instantiated by <a href="http://docs.oracle.com/javaee/6/tutorial/doc/giwhb.html">CDI</a> through dependency injection.</p>

<p>Just to fix the vocabulary, here some definition about Aspect Oriented Programming:</p>

<ul>
<li>Advice: code at it executed at a certain point in the code. This point is called a join point;</li>
<li>Join point: place in the code at which a given advice is executed.;</li>
<li>Pointcut: set of join point, usually described by a meta data that can be internal or external to the program (xml, annotations);</li>
<li>Aspect: advice + its pointcut;</li>
</ul>


<p>In Java EE6, an interceptor is made of an annotation that characterizes an aspect and an
implementation for that annotation. The annotation is placed at a join point, that is a place in the code where a specific advice must be executed. Usually around a method call. However, JEE6
interceptors are not as powerful as advanced AOP frameworks such as AspectJ, it provides enough
facility to decouple non-functional behaviors from the business code. That is exactly what we want
to achieve here. Let us now illustrate JEE6 interceptors through the implementation of a declarative security annotation that protects calls to the service layer.</p>

<h4>A meta data that asks for security</h4>

<p>The first thing is to declare an annotation that is parametrized by an array of <code>String</code> that
represents roles. This is presented in the following snippet. The annotation <code>InterceptorBinding</code>
is required to mark the annotation as a pointcut. The <code>@Retention(RetentionPolicy.RUNTIME)</code>
declares that Then <code>@Target({ ElementType.METHOD, ElementType.TYPE })</code> tells that the annotation
can be applied at both method level and type level. Finally, the member <code>String[] roles();</code>
declares that the annotation has a parameter called <code>roles</code>.</p>

<p>```java Secure.java
@InterceptorBinding
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD, ElementType.TYPE })
public @interface Secure {</p>

<pre><code>@Nonbinding
String[] roles();
</code></pre>

<p>}
```</p>

<h4>The interceptor (advice) that check the authorisation</h4>

<p>The next step is to program an advice. To that end, a
simple class must be annotated by the annotation <code>@Interceptor</code> and by the annotation that it
implements <code>@Secure(roles = { })</code> (i.e. the pointcut). The method that is annotated by
<code>@AroundInvoke</code> is executed by the container when it encounters a method annotated by <code>@Secure</code>
(i.e. join point). The name of the method (e.g. <code>invoke</code> ) does not matter as long as it returns an
<code>Object</code> and it accepts an <code>InvocationContext</code> as a parameter. This context contains information
about the intercepted method.</p>

<p>About the method itself, <code>getRoles</code> is a private method (given hereafter) that extract the list
of roles that are authorised to this method. The <code>SecurityContext</code> is described below and is
container for the <code>ThreadLocal</code> variable that contains the principal of the current user. The
method <code>principal.isUserInRoles(roles)</code> returns true if one the roles matches the expected
authorisation. If it is not the case an exception is raised and the interceptor stops there without
having executed the intercepted method. Otherwise, the interceptor goes on and executes the
intercepted method and finally returns its return value by executing <code>return context.proceed()</code> .</p>

<p>```java SecurityInterceptor.java CDI Interceptor
@Secure(roles = { })
@Interceptor
public class SecurityInterceptor implements Serializable {</p>

<pre><code>@AroundInvoke
public Object invoke(final InvocationContext context) throws Exception {
    String[] roles = getRoles(context.getMethod());
    MyPrincipal principal = SecurityContext.getPrincipal();

    if (!principal.isUserInRoles(roles)) {
        throw new IllegalAccessException("Current user not autorised!");
    }

    return context.proceed();
}

private String[] getRoles(final Method method) {
    ...
}
</code></pre>

<p>}
```</p>

<p>The private method getRoles scans the class of the method that has been intercepted in order to
discover the list of roles. First it scans at method level (<code>method.isAnnotationPresent</code> ) to
find the annotation <code>Secure.class</code> that has been described above. If it does not find the proper
annotation then it scans at class level (<code>method.getDeclaringClass().isAnnotationPresent</code> ).
Remember that we allow to put the annotation at the method level AND at the class level.</p>

<p>```java Method that scans the caller for annotation parameters
private String[] getRoles(final Method method) {</p>

<pre><code>if (method.isAnnotationPresent(Secure.class)) {
    return method.getAnnotation(Secure.class).roles();
}

if (method.getDeclaringClass().isAnnotationPresent(Secure.class)) {
    return method.getDeclaringClass().getAnnotation(Secure.class).roles();
}

return null;
</code></pre>

<p>}
```</p>

<p>The last step to activate the interceptor is to declare it in the <code>beans.xml</code> file. Remember that it works
thanks to CDI and only for the beans managed by CDI. By default, interceptors are disabled.</p>

<p>```xml beans.xml CDI descriptor
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</p>

<pre><code>xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://jboss.org/schema/cdi/beans_1_0.xsd"&gt;
&lt;interceptors&gt;
    &lt;class&gt;ch.demo.business.interceptors.SecurityInterceptor&lt;/class&gt;       
&lt;/interceptors&gt;
</code></pre>

<p></beans>
```</p>

<h4>How to populate the ThreadLocal variable with principal information</h4>

<p>So far, we did intercept the method call and check whether the current principal associated with
the thread is authorised to access to a the intercepted method. The problem is that in servlet
containers the security is at web level and we would to propagate this information. To that end, we
will use the concept of <a href="http://en.wikipedia.org/wiki/Thread-local_storage">thread local</a>
variables.</p>

<p>The following class contains a thread-local variable <code>principalHolder</code> that holds the current
(thread-local) principal. This assumes that a thread is processed by one and only one thread from A
to Z. This is the case for servlet engines but not always for application servers. In the latter
case, the vendor-specific security mechanism is much better as it takes things such as clustering
into account. The method <code>setPrincipal</code> is invoked at the beginning of a new request when it is
authenticated and authorised at the web level. <code>removePrincipal</code> cleans up the Thread-Local value
at the end of the request processing.</p>

<p>```java SecurityContext.java Thread-local container for the principal
public final class SecurityContext implements Serializable {</p>

<pre><code>private static InheritableThreadLocal&lt;MyPrincipal&gt; principalHolder = 
            new InheritableThreadLocal&lt;MyPrincipal&gt;();

private SecurityContext() { }

public static MyPrincipal getPrincipal() {
    if (principalHolder.get() == null) {
        principalHolder.set(new MyPrincipal(null, null));
    }
    return (MyPrincipal) principalHolder.get();
}

public static void setPrincipal(final MyPrincipal principal) {
    principalHolder.set(principal);
}

public static void removePrincipal() {
    principalHolder.remove();
}
</code></pre>

<p>}
```</p>

<p>The last step is to populate the principal and its associated roles to the thread-local container
when the request is initialized. For that purpose, we use a request listener that is invoked when a new
request has been submit and just before its destruction. On initialization, the method
<code>getMyPrincipal</code> extracts the principal from the request <code>request.getUserPrincipal()</code>. The
resulting principal is put in the thread-local by <code>SecurityContext.setPrincipal</code>.</p>

<p><code>getMyPrincipal</code> also goes through the list of roles and adds the authorised roles using <code>request.isUserInRole</code> from <code>HttpServletRequest</code>.</p>

<p>```java SecurityListener.java
public class SecurityListener implements ServletRequestListener {</p>

<pre><code>private static List&lt;String&gt; roles = null;

@Override
public void requestInitialized(final ServletRequestEvent sre) {
    SecurityContext.setPrincipal(getMyPrincipal((HttpServletRequest) sre.getServletRequest()));
}

@Override
public void requestDestroyed(final ServletRequestEvent sre) {
    SecurityContext.removePrincipal();
}

public static MyPrincipal getMyPrincipal(final HttpServletRequest request) {
    if (roles == null) {
        roles = getSecurityRoles(request.getServletContext());
    }

    Principal principal = (Principal) request.getUserPrincipal();
    List&lt;String&gt; currentRoles = new ArrayList&lt;String&gt;();
    for (String role : roles) {
        if (request.isUserInRole(role)) {
            currentRoles.add(role);
        }
    }
    return new MyPrincipal(principal, currentRoles);
}

public static synchronized List&lt;String&gt; getSecurityRoles(final ServletContext ctx) {
    ...
}
</code></pre>

<p>}
```</p>

<p>The next method is not very elegant but this is the only way that have found to extract the role
list that is required by the current web application. It parses the <code>web.xml</code>, looking for
<code>role-name</code> elements that describe a role.</p>

<p>```java Extract the role list from web.xml
public static synchronized List<String> getSecurityRoles(final ServletContext ctx) {</p>

<pre><code>List&lt;String&gt; r = new ArrayList&lt;String&gt;();
InputStream is = ctx.getResourceAsStream("/WEB-INF/web.xml");

DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
dbFactory.setNamespaceAware(true);
try {
    DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
    Document doc = dBuilder.parse(is);
    doc.getDocumentElement().normalize();

    NodeList elements = doc.getElementsByTagName("role-name");
    for (int i = 0; i &lt; elements.getLength(); i++) {
        r.add(elements.item(i).getTextContent().trim());
    }
} catch (Exception e) {
    new IllegalAccessException(e.getMessage());
}
return r;
</code></pre>

<p>}
```</p>

<p>Finally, the listener is enabled by putting the following lines in <code>web.xml</code>.
```xml web.xml
<listener></p>

<pre><code>&lt;listener-class&gt;ch.demo.web.SecurityListener&lt;/listener-class&gt;
</code></pre>

<p></listener>
```</p>

<p>Whenever there is not redirect (that triggers a new request) after login or there is a manual call to JAAS, the
principal must be manually set into thread-local right after the login. This is because if the
security is checked right after authentication and the listener has already been called (at the beginning of the
request) it has been set to an invalid principal.</p>

<p><code>java
request.login(user, password);
SecurityContext.setPrincipal(SecurityListener.getMyPrincipal(request));
</code></p>

<h2>Conclusion</h2>

<p>In this post, we have seen how to write a JEE6 interceptor to authorise access to service level methods in servlet containers. The examples used in this blog are to be found in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project on <a href="http://code.google.com">Google code hosting</a>.</p>
]]></content>
  </entry>
  
</feed>
