<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Security | Steve Hostettler]]></title>
  <link href="http://hostettler.github.io/blog/categories/security/atom.xml" rel="self"/>
  <link href="http://hostettler.github.io/"/>
  <updated>2014-05-11T13:23:26+02:00</updated>
  <id>http://hostettler.github.io/</id>
  <author>
    <name><![CDATA[Steve Hostettler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A JEE6 security interceptor for Tomcat 7]]></title>
    <link href="http://hostettler.github.io/blog/2012/05/02/a-jee6-security-interceptor-for-tomcat-7/"/>
    <updated>2012-05-02T18:23:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/05/02/a-jee6-security-interceptor-for-tomcat-7</id>
    <content type="html"><![CDATA[<p>Security in Java EE is a well-known subject and JAAS, the framework that manages security, is
stable and reliable. Nevertheless, its API is quite low level and not always very convenient. For
that reason, there exist a number of frameworks that have been built on top of JAAS that provide
nice abstractions and convenient tools. This is especially true for the JEE application servers such as <a href="http://glassfish.java.net/">Glassfish</a>, <a href="http://www.jboss.org/">JBoss</a> and the like.</p>

<p>In servlet containers such as <a href="http://tomcat.apache.org/">Tomcat</a> or <a href="http://jetty.codehaus.org/jetty/">Jetty</a> however, only the web components are secured and it is not trivial to secure services and the data access layer. This can be solved by integrating framework such as <a href="http://static.springsource.org/spring-security/site/">Spring Security</a>, <a href="http://shiro.apache.org/">Apache Shiro</a>.</p>

<p>As always it is not always possible to put a new framework or library in place. I will not
discuss whether it is a good or a bad idea to develop a new security mechanism. Nevertheless, a good
rule of thumb is to reuse existing components and not reinvent the wheel ... when possible. If for
let's say licensing reasons, it is not possible: here is a way to provide a simple declarative
authorisation procedure based on JAAS and the JEE6 interceptors. The objective is to propagate the
authorisation to non-web layers such as services or data access layer through a thread-local
variable.</p>

<p>The goal is to be able to write something similar to the following snippet. The idea is to annotate
a method (or a class) with a list of roles that are authorised. If the method executes in a context
in which a user has not enough rights, it raises an exception.</p>

<p>```java Example of a service layer protected by JEE6 interceptor
@Secure(roles = { "user" })
public List<Student> getAll() {</p>

<pre><code>...
</code></pre>

<p>}</p>

<p>@Secure(roles = { "admin" })
public void add(final Student student) {</p>

<pre><code>...
</code></pre>

<p>}
```</p>

<h3>Java Authentication and Authorisation System</h3>

<p>Java Authentication and Authorisation System (JAAS) provides a security infrastructure for JAVA.
Both <strong>authentication</strong> (are you who you pretend to be?) and <strong>authorisation</strong> (are you allowed to do something you would like to do?) are covered. JAAS relies on the concept of principal.
A principal is a particular identity of a user (e.g. social security id, driver licence id, ...).
By default, in JAVA SE, there is no easy way to have the list of roles granted to a given user.
To solve that problem, we need a bean that knows to which role a given Principal is authorised.
This is the role of <code>MyPrincipal</code>.</p>

<p>```java A custom principal that contains the roles
public class MyPrincipal implements Principal, Serializable {</p>

<pre><code>public MyPrincipal(final Principal pPrincipal, final List&lt;String&gt; pRoles) {
    this.principal = pPrincipal;
    this.roles = pRoles;
}
...  
public boolean isUserInRole(final String pRole) {
    return roles.contains(pRole);
}
</code></pre>

<p>}
```</p>

<h3>JEE6 Interceptors</h3>

<p>Since JEE6, a feature called interceptors enables simple
<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect Oriented Programming</a> without
using any specific framework. It works, of course, only on managed classes. Namely, classes that are instantiated by <a href="http://docs.oracle.com/javaee/6/tutorial/doc/giwhb.html">CDI</a> through dependency injection.</p>

<p>Just to fix the vocabulary, here some definition about Aspect Oriented Programming:</p>

<ul>
<li>Advice: code at it executed at a certain point in the code. This point is called a join point;</li>
<li>Join point: place in the code at which a given advice is executed.;</li>
<li>Pointcut: set of join point, usually described by a meta data that can be internal or external to the program (xml, annotations);</li>
<li>Aspect: advice + its pointcut;</li>
</ul>


<p>In Java EE6, an interceptor is made of an annotation that characterizes an aspect and an
implementation for that annotation. The annotation is placed at a join point, that is a place in the code where a specific advice must be executed. Usually around a method call. However, JEE6
interceptors are not as powerful as advanced AOP frameworks such as AspectJ, it provides enough
facility to decouple non-functional behaviors from the business code. That is exactly what we want
to achieve here. Let us now illustrate JEE6 interceptors through the implementation of a declarative security annotation that protects calls to the service layer.</p>

<h4>A meta data that asks for security</h4>

<p>The first thing is to declare an annotation that is parametrized by an array of <code>String</code> that
represents roles. This is presented in the following snippet. The annotation <code>InterceptorBinding</code>
is required to mark the annotation as a pointcut. The <code>@Retention(RetentionPolicy.RUNTIME)</code>
declares that Then <code>@Target({ ElementType.METHOD, ElementType.TYPE })</code> tells that the annotation
can be applied at both method level and type level. Finally, the member <code>String[] roles();</code>
declares that the annotation has a parameter called <code>roles</code>.</p>

<p>```java Secure.java
@InterceptorBinding
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD, ElementType.TYPE })
public @interface Secure {</p>

<pre><code>@Nonbinding
String[] roles();
</code></pre>

<p>}
```</p>

<h4>The interceptor (advice) that check the authorisation</h4>

<p>The next step is to program an advice. To that end, a
simple class must be annotated by the annotation <code>@Interceptor</code> and by the annotation that it
implements <code>@Secure(roles = { })</code> (i.e. the pointcut). The method that is annotated by
<code>@AroundInvoke</code> is executed by the container when it encounters a method annotated by <code>@Secure</code>
(i.e. join point). The name of the method (e.g. <code>invoke</code> ) does not matter as long as it returns an
<code>Object</code> and it accepts an <code>InvocationContext</code> as a parameter. This context contains information
about the intercepted method.</p>

<p>About the method itself, <code>getRoles</code> is a private method (given hereafter) that extract the list
of roles that are authorised to this method. The <code>SecurityContext</code> is described below and is
container for the <code>ThreadLocal</code> variable that contains the principal of the current user. The
method <code>principal.isUserInRoles(roles)</code> returns true if one the roles matches the expected
authorisation. If it is not the case an exception is raised and the interceptor stops there without
having executed the intercepted method. Otherwise, the interceptor goes on and executes the
intercepted method and finally returns its return value by executing <code>return context.proceed()</code> .</p>

<p>```java SecurityInterceptor.java CDI Interceptor
@Secure(roles = { })
@Interceptor
public class SecurityInterceptor implements Serializable {</p>

<pre><code>@AroundInvoke
public Object invoke(final InvocationContext context) throws Exception {
    String[] roles = getRoles(context.getMethod());
    MyPrincipal principal = SecurityContext.getPrincipal();

    if (!principal.isUserInRoles(roles)) {
        throw new IllegalAccessException("Current user not autorised!");
    }

    return context.proceed();
}

private String[] getRoles(final Method method) {
    ...
}
</code></pre>

<p>}
```</p>

<p>The private method getRoles scans the class of the method that has been intercepted in order to
discover the list of roles. First it scans at method level (<code>method.isAnnotationPresent</code> ) to
find the annotation <code>Secure.class</code> that has been described above. If it does not find the proper
annotation then it scans at class level (<code>method.getDeclaringClass().isAnnotationPresent</code> ).
Remember that we allow to put the annotation at the method level AND at the class level.</p>

<p>```java Method that scans the caller for annotation parameters
private String[] getRoles(final Method method) {</p>

<pre><code>if (method.isAnnotationPresent(Secure.class)) {
    return method.getAnnotation(Secure.class).roles();
}

if (method.getDeclaringClass().isAnnotationPresent(Secure.class)) {
    return method.getDeclaringClass().getAnnotation(Secure.class).roles();
}

return null;
</code></pre>

<p>}
```</p>

<p>The last step to activate the interceptor is to declare it in the <code>beans.xml</code> file. Remember that it works
thanks to CDI and only for the beans managed by CDI. By default, interceptors are disabled.</p>

<p>```xml beans.xml CDI descriptor
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</p>

<pre><code>xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://jboss.org/schema/cdi/beans_1_0.xsd"&gt;
&lt;interceptors&gt;
    &lt;class&gt;ch.demo.business.interceptors.SecurityInterceptor&lt;/class&gt;       
&lt;/interceptors&gt;
</code></pre>

<p></beans>
```</p>

<h4>How to populate the ThreadLocal variable with principal information</h4>

<p>So far, we did intercept the method call and check whether the current principal associated with
the thread is authorised to access to a the intercepted method. The problem is that in servlet
containers the security is at web level and we would to propagate this information. To that end, we
will use the concept of <a href="http://en.wikipedia.org/wiki/Thread-local_storage">thread local</a>
variables.</p>

<p>The following class contains a thread-local variable <code>principalHolder</code> that holds the current
(thread-local) principal. This assumes that a thread is processed by one and only one thread from A
to Z. This is the case for servlet engines but not always for application servers. In the latter
case, the vendor-specific security mechanism is much better as it takes things such as clustering
into account. The method <code>setPrincipal</code> is invoked at the beginning of a new request when it is
authenticated and authorised at the web level. <code>removePrincipal</code> cleans up the Thread-Local value
at the end of the request processing.</p>

<p>```java SecurityContext.java Thread-local container for the principal
public final class SecurityContext implements Serializable {</p>

<pre><code>private static InheritableThreadLocal&lt;MyPrincipal&gt; principalHolder = 
            new InheritableThreadLocal&lt;MyPrincipal&gt;();

private SecurityContext() { }

public static MyPrincipal getPrincipal() {
    if (principalHolder.get() == null) {
        principalHolder.set(new MyPrincipal(null, null));
    }
    return (MyPrincipal) principalHolder.get();
}

public static void setPrincipal(final MyPrincipal principal) {
    principalHolder.set(principal);
}

public static void removePrincipal() {
    principalHolder.remove();
}
</code></pre>

<p>}
```</p>

<p>The last step is to populate the principal and its associated roles to the thread-local container
when the request is initialized. For that purpose, we use a request listener that is invoked when a new
request has been submit and just before its destruction. On initialization, the method
<code>getMyPrincipal</code> extracts the principal from the request <code>request.getUserPrincipal()</code>. The
resulting principal is put in the thread-local by <code>SecurityContext.setPrincipal</code>.</p>

<p><code>getMyPrincipal</code> also goes through the list of roles and adds the authorised roles using <code>request.isUserInRole</code> from <code>HttpServletRequest</code>.</p>

<p>```java SecurityListener.java
public class SecurityListener implements ServletRequestListener {</p>

<pre><code>private static List&lt;String&gt; roles = null;

@Override
public void requestInitialized(final ServletRequestEvent sre) {
    SecurityContext.setPrincipal(getMyPrincipal((HttpServletRequest) sre.getServletRequest()));
}

@Override
public void requestDestroyed(final ServletRequestEvent sre) {
    SecurityContext.removePrincipal();
}

public static MyPrincipal getMyPrincipal(final HttpServletRequest request) {
    if (roles == null) {
        roles = getSecurityRoles(request.getServletContext());
    }

    Principal principal = (Principal) request.getUserPrincipal();
    List&lt;String&gt; currentRoles = new ArrayList&lt;String&gt;();
    for (String role : roles) {
        if (request.isUserInRole(role)) {
            currentRoles.add(role);
        }
    }
    return new MyPrincipal(principal, currentRoles);
}

public static synchronized List&lt;String&gt; getSecurityRoles(final ServletContext ctx) {
    ...
}
</code></pre>

<p>}
```</p>

<p>The next method is not very elegant but this is the only way that have found to extract the role
list that is required by the current web application. It parses the <code>web.xml</code>, looking for
<code>role-name</code> elements that describe a role.</p>

<p>```java Extract the role list from web.xml
public static synchronized List<String> getSecurityRoles(final ServletContext ctx) {</p>

<pre><code>List&lt;String&gt; r = new ArrayList&lt;String&gt;();
InputStream is = ctx.getResourceAsStream("/WEB-INF/web.xml");

DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
dbFactory.setNamespaceAware(true);
try {
    DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
    Document doc = dBuilder.parse(is);
    doc.getDocumentElement().normalize();

    NodeList elements = doc.getElementsByTagName("role-name");
    for (int i = 0; i &lt; elements.getLength(); i++) {
        r.add(elements.item(i).getTextContent().trim());
    }
} catch (Exception e) {
    new IllegalAccessException(e.getMessage());
}
return r;
</code></pre>

<p>}
```</p>

<p>Finally, the listener is enabled by putting the following lines in <code>web.xml</code>.
```xml web.xml
<listener></p>

<pre><code>&lt;listener-class&gt;ch.demo.web.SecurityListener&lt;/listener-class&gt;
</code></pre>

<p></listener>
```</p>

<p>Whenever there is not redirect (that triggers a new request) after login or there is a manual call to JAAS, the
principal must be manually set into thread-local right after the login. This is because if the
security is checked right after authentication and the listener has already been called (at the beginning of the
request) it has been set to an invalid principal.</p>

<p><code>java
request.login(user, password);
SecurityContext.setPrincipal(SecurityListener.getMyPrincipal(request));
</code></p>

<h2>Conclusion</h2>

<p>In this post, we have seen how to write a JEE6 interceptor to authorise access to service level methods in servlet containers. The examples used in this blog are to be found in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project on <a href="http://code.google.com">Google code hosting</a>.</p>
]]></content>
  </entry>
  
</feed>
