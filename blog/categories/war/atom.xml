<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: WAR | Steve Hostettler]]></title>
  <link href="http://hostettler.github.io/blog/categories/war/atom.xml" rel="self"/>
  <link href="http://hostettler.github.io/"/>
  <updated>2014-06-30T23:50:34+02:00</updated>
  <id>http://hostettler.github.io/</id>
  <author>
    <name><![CDATA[Steve Hostettler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Embedded Web Application integration testing using Tomcat 7 and JUnit]]></title>
    <link href="http://hostettler.github.io/blog/2012/04/09/embedded-jee-web-application-integration-testing-using-tomcat-7/"/>
    <updated>2012-04-09T14:39:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/04/09/embedded-jee-web-application-integration-testing-using-tomcat-7</id>
    <content type="html"><![CDATA[<p>To follow up on my previous post about <a href="/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap/">how to programmatically build a web archive</a>, I propose to look at how to deploy this archive in a Tomcat instance that is embedded into a JUnit test.</p>

<p>As usual, the presented snippets are available in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> application. I will first look at the dependencies, then I will show how to configure Tomcat and finally how to start and stop the embedded instance.</p>

<p>The first dependency is the embedded Tomcat core component. JULI which stands for Java Utility Logging Implementation that is the container extension of common logging. The ECJ compiler and JASPER are required to handle JSPs. Of course all these dependencies are scoped to test only.</p>

<h2>The dependencies</h2>

<p>```xml Maven dependencies necessary to start an embedded Tomcat instance into JUnit tests.
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
&lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;
&lt;version&gt;7.0.26&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
&lt;artifactId&gt;tomcat-embed-logging-juli&lt;/artifactId&gt;
&lt;version&gt;7.0.26&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;
&lt;artifactId&gt;ecj&lt;/artifactId&gt;
&lt;version&gt;3.7.1&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
&lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
&lt;version&gt;7.0.26&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;junit&lt;/groupId&gt;
&lt;artifactId&gt;junit&lt;/artifactId&gt;
&lt;version&gt;4.10&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<h2>Configuring Tomcat</h2>

<p>The following snippet prepares the embedded instance. The static member <code>mTomcat</code> references a new instance of Tomcat. As Tomcat still requires a file system to work, a temporary directory is used to put all the temporary files. To that end, we use the <code>java.io.tmpdir</code> java property.
These variables are shared among the test cases.</p>

<p>```java Shared static variables</p>

<p>/<strong> The tomcat instance. */
private Tomcat mTomcat;
/</strong> The temporary directory in which Tomcat and the app are deployed. */
private String mWorkingDir = System.getProperty("java.io.tmpdir");
```</p>

<p>As we want to use the same Tomcat configuration among all test cases, the initialization is put in a method annotated with <code>@Before</code>. First, the method sets the port to <code>0</code>. This tells the engine to choose the port to run on by itself.  This is especially useful to avoid  starting the embedded Tomcat on a already used port as <code>8080</code> for instance.
Then the base directory is set <code>mTomcat.setBaseDir()</code> to the temporary directory. Without doing that, Tomcat would start in the current directory. The rest of the method configures the way WAR are managed by the engine.</p>

<p>```java Configuration of the embedded Tomcat instance
@Before
public void setup() throws Throwable {</p>

<pre><code>mTomcat = new Tomcat();
mTomcat.setPort(0);
mTomcat.setBaseDir(mWorkingDir);
mTomcat.getHost().setAppBase(mWorkingDir);
mTomcat.getHost().setAutoDeploy(true);
mTomcat.getHost().setDeployOnStartup(true);
...
</code></pre>

<p>}
```</p>

<p>The rest of the method builds a reference to a directory (based into the temporary directory) that contains the web application. This directory is deleted if it exists to ensure redeployment of the WAR. Finally, the WAR built as explained <a href="/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap/">there</a> is exported into the temporary directory.</p>

<p>Finally, the web application is added to the Tomcat instance. More specifically, a path
exploded version <code>webApp.getAbsolutePath()</code> of the WAR is linked to a context <code>contextPath</code>.</p>

<p>```java Cleaning and preparing the web application deployment.
@Before
public void setup() throws Throwable {</p>

<pre><code>...
String contextPath = "/" + getApplicationId();
File webApp = new File(mWorkingDir, getApplicationId());
File oldWebApp = new File(webApp.getAbsolutePath());
FileUtils.deleteDirectory(oldWebApp);
new ZipExporterImpl(createWebArchive()).exportTo(new File(mWorkingDir + "/" + getApplicationId() + ".war"),
        true);
mTomcat.addWebapp(mTomcat.getHost(), contextPath, webApp.getAbsolutePath());    
</code></pre>

<p>}
```</p>

<h2>Starting Tomcat</h2>

<p>Now that Tomcat has been configured, the next step is to start it. We want a fresh Tomcat
for each and every test case. This way, a failed test does not have repercussions on the subsequent tests (e.g. session information, memory leaks);</p>

<p>```java Start the embedded Tomcat instance and add a web application
@Before
public void setup() throws Throwable {</p>

<pre><code>...
mTomcat.start();
</code></pre>

<p>}
```</p>

<p>If necessary, the actual port on which Tomcat has been started can be retrieved using the following snippet.
```java
protected int getTomcatPort() {</p>

<pre><code>return mTomcat.getConnector().getLocalPort();
</code></pre>

<p>}
```</p>

<p>Finally, after the test, the Tomcat instance is stopped and destroyed clearing the way for the next test.</p>

<h2>Stopping Tomcat</h2>

<p>```java
@After
public final void teardown() throws Throwable {</p>

<pre><code>if (mTomcat.getServer() != null
        &amp;&amp; mTomcat.getServer().getState() != LifecycleState.DESTROYED) {
    if (mTomcat.getServer().getState() != LifecycleState.STOPPED) {
            mTomcat.stop();
    }
    mTomcat.destroy();
}
</code></pre>

<p>}
```</p>

<h2>Conclusion</h2>

<p>In this post, we have seen how to start an embedded version of Tomcat into a JUnit fixture.
The examples used in this blog are to be found in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project on <a href="http://code.google.com">Google code hosting</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programmatically build web archives using ShrinkWrap]]></title>
    <link href="http://hostettler.github.io/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap/"/>
    <updated>2012-04-05T09:09:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap</id>
    <content type="html"><![CDATA[<p>While doing integration tests on web applications, it is important to restrict the application to the strict minimum necessary for any given test. It helps to improve the startup time as well as to reduce unexpected interactions.
To that end, I use <a href="http://www.jboss.org/shrinkwrap">ShrinkWrap</a> from <a href="http://www.jboss.org/">JBoss</a> that is a very nice a simple API to build Java archives (e.g., JAR WAR, EAR). This post describes how to programmatically build a WAR file that can be deployed on an embedded server for integration
testing. For more details on how to use this web archive in JUnit fixtures please refer to this <a href="/blog/2012/04/09/embedded-jee-web-application-integration-testing-using-tomcat-7/">article</a>. The following snippet gets the ShrinkWrap package from the JBoss repository. As I only use it for test purposes, I restricted its use to the test scope.</p>

<p><strong>ShrinkWrap</strong> is available as a Maven dependency:
```xml Maven dependencies for the ShrinkWrap project
<repositories>
...</p>

<pre><code>&lt;repository&gt;
    &lt;id&gt;repository.jboss.org&lt;/id&gt;
    &lt;name&gt;JBoss Repository&lt;/name&gt;
    &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public-jboss/&lt;/url&gt;
&lt;/repository&gt;
...
</code></pre>

<p></repositories>
...
<dependencies></p>

<pre><code>...
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.shrinkwrap&lt;/groupId&gt;
    &lt;artifactId&gt;shrinkwrap-api&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-alpha-12&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.jboss.shrinkwrap&lt;/groupId&gt;
    &lt;artifactId&gt;shrinkwrap-impl&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-alpha-12&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p>...
<dependencies>
```</p>

<h2>Building the archive</h2>

<p>The first step is to crate a web archive a.k.a. a WAR file. As we want to produce a WAR file, we use the <code>WebArchive.class</code> parameter
to the <code>ShrinkWrap.create</code> method. It is also possible to produce JAR (<code>JavaArchive.class</code>) and EAR (<code>EnterpriseArchive.class</code>).
<code>java Creation of a Web Archive
WebArchive archive = ShrinkWrap.create(WebArchive.class, "test.war");
</code>
The next step to build a WAR is to provide the <code>web.xml</code> for you project. Again this can a be a simplified version of the web descriptor to improve startup time or limit dependencies. In the following example, the files are taken from a maven directory structure.</p>

<p>```java Add a web descriptor to the archive
private static final String WEBAPP_SRC = "src/main/webapp";</p>

<p>archive.setWebXML(new File(WEBAPP_SRC, "WEB-INF/web.xml"))
<code>
Now that we have a web descriptor, let's add some classes that are required to run the application. To not having to add each single class individually, it is possible to a complete package to the archive.
</code>java add a package to the runtime classes
archive.addPackage(java.lang.Package.getPackage("ch.demo.web"))
```</p>

<p>It is also possible to add individual classes:
<code>java add a class to the runtime classes
archive.addClasses(Student.class, Address.class);
</code></p>

<p>For JSF applications, we add add the <code>faces-config.xml</code>.
<code>java
archive.addAsWebInfResource(new File(WEBAPP_SRC, "WEB-INF/faces-config.xml"))
</code></p>

<p>And similarly, let's add the CDI descriptor into <code>WEB-INF</code>. As we do not need to create a specific <code>`beans.xml</code>,
we add an empty descriptor:
<code>java
archive.addAsWebInfResource(EmptyAsset.INSTANCE, "beans.xml")
</code></p>

<p>Let's finally add standard web resources such as <code>xhtml</code> files or static files:
<code>java
archive.addAsWebResource(new File(WEBAPP_SRC, "login.xhtml"));
</code></p>

<p>As ShrinkWrap uses <a href="http://en.wikipedia.org/wiki/Method_chaining">Method Chaining</a>, it is possible to chain <code>add</code> class to fill the archive.
```java Build a simple web application    <br/>
archive.setWebXML(new File(WEBAPP_SRC, "WEB-INF/web.xml"))</p>

<pre><code>.addAsWebInfResource(EmptyAsset.INSTANCE, "beans.xml")
.addAsWebInfResource(new File(WEBAPP_SRC, "WEB-INF/faces-config.xml"))
.addPackage(java.lang.Package.getPackage("ch.demo.web"))
.addAsWebResource(new File(WEBAPP_SRC, "login.xhtml"))
.addAsWebResource(new File(WEBAPP_SRC, "index.jsp"))
.addAsWebResource(new File(WEBAPP_SRC, "xhtml/listStudents.xhtml"), "xhtml/listStudents.xhtml");
</code></pre>

<p>```</p>

<p>Please note that when using maven to execute the tests, most of the required libraries are already on the classpath. Therefore, we often do not need to add any library or jars to the web archive.</p>

<h2>Using the archive</h2>

<p>After having built the package, we need to export it either as a war or as an exploded directory.
The following snippet produces a WAR file named after the archive. The second parameter states whether
a existing archive can be overwritten.
<code>java Produce the actual war
new ZipExporterImpl(archive).exportTo(new File(archive.getName()), true);
</code>
Alternatively it is possible to produce an exploded archive:
<code>java Produce an exploded archive
new ExplodedExporterImpl(archive).exportExploded(new File(archive.getName()));
</code></p>

<h2>Conclusion</h2>

<p>We have seen how to use ShrinkWrap to programmatically build Web archives. This is especially useful to test smaller version of your web application during integration testing. It helps to test webapps with mock services and to improve the startup time. The examples used in this blog are to be found in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project on <a href="http://code.google.com">Google code hosting</a>.</p>
]]></content>
  </entry>
  
</feed>
