<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Web application | Steve Hostettler]]></title>
  <link href="http://hostettler.github.io/blog/categories/web-application/atom.xml" rel="self"/>
  <link href="http://hostettler.github.io/"/>
  <updated>2014-06-30T23:50:34+02:00</updated>
  <id>http://hostettler.github.io/</id>
  <author>
    <name><![CDATA[Steve Hostettler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Selenium for web integration testing]]></title>
    <link href="http://hostettler.github.io/blog/2012/04/16/using-selenium-for-web-integration-testing/"/>
    <updated>2012-04-16T18:57:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/04/16/using-selenium-for-web-integration-testing</id>
    <content type="html"><![CDATA[<p>Following up on my previous posts (<a href="/blog/2012/04/09/embedded-jee-web-application-integration-testing-using-tomcat-7/">here</a>
and <a href="/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap/">here</a> about integration testing
of JEE web applications, I will present how to write smoke tests using Selenium. The idea is to
detect whether important regressions have been introduced. This is especially useful to detect
configuration and navigation problems. I've split the test in three parts:</p>

<ol>
<li>starting and stopping the container. Embedded Tomcat 7 in our case. This is described
<a href="/blog/2012/04/09/embedded-jee-web-application-integration-testing-using-tomcat-7">here</a>;</li>
<li>building the WAR file to test. To that end, you can look at this
<a href="/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap">post</a> that describes how to
build such a test archive using Shrinkwrap;</li>
<li>finally, we must build the test case. This is the goal of this post.</li>
</ol>


<p>Testing a use case requires to be able to:</p>

<ol>
<li>get a page at a given URL;</li>
<li>input test data into the web elements;</li>
<li>assert whether the server answers as expected.</li>
</ol>


<p>Selenium provides an easy API to fetch URLs
As these are smoke tests, using the <code>HtmlUnitDriver</code> instead of a specific browser is sufficient.
We do not want to detect minor display problems but rather important functional problems.</p>

<p>Selenium has many different drivers for many different browser. The problem is that it opens the
browser in a new window. I prefer to have the continuous integration running headless.</p>

<p>The following dependencies are required to run the tests.</p>

<p>```xml Maven dependencies
<dependency></p>

<pre><code>&lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;
&lt;artifactId&gt;selenium-java&lt;/artifactId&gt;
&lt;version&gt;2.20.0&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;net.sourceforge.htmlunit&lt;/groupId&gt;
&lt;artifactId&gt;htmlunit&lt;/artifactId&gt;
&lt;version&gt;2.9&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<p>First, let's build a new headless driver. This object simulates the browser. It manages the HTTP part as
well as parsing the HTML and the javascript code that is returned.</p>

<p><code>java
WebDriver driver = new HtmlUnitDriver();
</code></p>

<p>The next step is to ask the driver to load the home page that we want to test. For
convenience, in my previous posts I defined a method that returns the current Tomcat port and the
application context.</p>

<p><code>java
driver.get("http://localhost:" + getTomcatPort() + "/" + getApplicationId());
</code></p>

<p>Let's assume that the home page redirects to a login page that has two text boxes (respectively
called <code>username</code> and password). The following snippet uses XPATH expressions to locate web elements.
First, it locates a HTML element of type <code>input</code> that has an
attribute  <code>id</code> set to <code>username</code>. If this web element is not present, the driver will raise an exception.
This allows to easily detect whether a widget has been accidentally removed.</p>

<p><code>java
WebElement username = driver.findElement(By.xpath("//input[contains(@id,'username')]"));
</code></p>

<p>Now we can interact with the previous element. For instance, to simulate a user that types in its username (<code>admin</code>).
<code>java
username.sendKeys("admin");
</code></p>

<p>After that, Let's do the same for the web element called <code>password</code>.
<code>java
WebElement password = driver.findElement(By.xpath("//input[contains(@id,'password')]"));
password.sendKeys("admin");
</code></p>

<p>Finally, we locate a button called <code>login</code>and we simulate a click on it.</p>

<p><code>java
WebElement login = driver.findElement(By.xpath("//button[contains(@id,'login')]"));
login.click();
</code></p>

<p>On successful login, our example redirects to a page that contains a list of students.
The following assertion checks that the string <code>Student list</code> exists somewhere is the returned
HTML source code.</p>

<p><code>java
Assert.assertTrue(driver.getPageSource().contains("Student list"));
</code></p>

<p>With this approach, it is also very easy to do trivial security testing. For instance, let's check that
the application redirects (or forwards) the user to the login page upon unsuccessful login.
<code>java
WebElement username = driver.findElement(By.xpath("//input[contains(@id,'username')]"));
username.sendKeys("foo");
WebElement password = driver.findElement(By.xpath("//input[contains(@id,'password')]"));
password.sendKeys("foo");
WebElement login = driver.findElement(By.xpath("//button[contains(@id,'login')]"));
login.click();
Assert.assertTrue(driver.getPageSource().contains("username"));
Assert.assertTrue(driver.getPageSource().contains("password"));
Assert.assertTrue(driver.getPageSource().contains("login"));
</code></p>

<h2>Conclusion</h2>

<p>In this post, we have seen how to write smoke integration tests with Selenium. This is especially
useful to detect whether an important functionality has been hindered. For instance, a change in the
navigation or a unexpected change of the status (availability, visibility) of one the buttons or web elements.
I recommend implementing the three or four major scenarios with this technique. This is usually enough to
detect major problems. The examples used in this blog are to be found in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project on <a href="http://code.google.com">Google code hosting</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Embedded Web Application integration testing using Tomcat 7 and JUnit]]></title>
    <link href="http://hostettler.github.io/blog/2012/04/09/embedded-jee-web-application-integration-testing-using-tomcat-7/"/>
    <updated>2012-04-09T14:39:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/04/09/embedded-jee-web-application-integration-testing-using-tomcat-7</id>
    <content type="html"><![CDATA[<p>To follow up on my previous post about <a href="/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap/">how to programmatically build a web archive</a>, I propose to look at how to deploy this archive in a Tomcat instance that is embedded into a JUnit test.</p>

<p>As usual, the presented snippets are available in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> application. I will first look at the dependencies, then I will show how to configure Tomcat and finally how to start and stop the embedded instance.</p>

<p>The first dependency is the embedded Tomcat core component. JULI which stands for Java Utility Logging Implementation that is the container extension of common logging. The ECJ compiler and JASPER are required to handle JSPs. Of course all these dependencies are scoped to test only.</p>

<h2>The dependencies</h2>

<p>```xml Maven dependencies necessary to start an embedded Tomcat instance into JUnit tests.
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
&lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;
&lt;version&gt;7.0.26&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
&lt;artifactId&gt;tomcat-embed-logging-juli&lt;/artifactId&gt;
&lt;version&gt;7.0.26&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;
&lt;artifactId&gt;ecj&lt;/artifactId&gt;
&lt;version&gt;3.7.1&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
&lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
&lt;version&gt;7.0.26&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;junit&lt;/groupId&gt;
&lt;artifactId&gt;junit&lt;/artifactId&gt;
&lt;version&gt;4.10&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<h2>Configuring Tomcat</h2>

<p>The following snippet prepares the embedded instance. The static member <code>mTomcat</code> references a new instance of Tomcat. As Tomcat still requires a file system to work, a temporary directory is used to put all the temporary files. To that end, we use the <code>java.io.tmpdir</code> java property.
These variables are shared among the test cases.</p>

<p>```java Shared static variables</p>

<p>/<strong> The tomcat instance. */
private Tomcat mTomcat;
/</strong> The temporary directory in which Tomcat and the app are deployed. */
private String mWorkingDir = System.getProperty("java.io.tmpdir");
```</p>

<p>As we want to use the same Tomcat configuration among all test cases, the initialization is put in a method annotated with <code>@Before</code>. First, the method sets the port to <code>0</code>. This tells the engine to choose the port to run on by itself.  This is especially useful to avoid  starting the embedded Tomcat on a already used port as <code>8080</code> for instance.
Then the base directory is set <code>mTomcat.setBaseDir()</code> to the temporary directory. Without doing that, Tomcat would start in the current directory. The rest of the method configures the way WAR are managed by the engine.</p>

<p>```java Configuration of the embedded Tomcat instance
@Before
public void setup() throws Throwable {</p>

<pre><code>mTomcat = new Tomcat();
mTomcat.setPort(0);
mTomcat.setBaseDir(mWorkingDir);
mTomcat.getHost().setAppBase(mWorkingDir);
mTomcat.getHost().setAutoDeploy(true);
mTomcat.getHost().setDeployOnStartup(true);
...
</code></pre>

<p>}
```</p>

<p>The rest of the method builds a reference to a directory (based into the temporary directory) that contains the web application. This directory is deleted if it exists to ensure redeployment of the WAR. Finally, the WAR built as explained <a href="/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap/">there</a> is exported into the temporary directory.</p>

<p>Finally, the web application is added to the Tomcat instance. More specifically, a path
exploded version <code>webApp.getAbsolutePath()</code> of the WAR is linked to a context <code>contextPath</code>.</p>

<p>```java Cleaning and preparing the web application deployment.
@Before
public void setup() throws Throwable {</p>

<pre><code>...
String contextPath = "/" + getApplicationId();
File webApp = new File(mWorkingDir, getApplicationId());
File oldWebApp = new File(webApp.getAbsolutePath());
FileUtils.deleteDirectory(oldWebApp);
new ZipExporterImpl(createWebArchive()).exportTo(new File(mWorkingDir + "/" + getApplicationId() + ".war"),
        true);
mTomcat.addWebapp(mTomcat.getHost(), contextPath, webApp.getAbsolutePath());    
</code></pre>

<p>}
```</p>

<h2>Starting Tomcat</h2>

<p>Now that Tomcat has been configured, the next step is to start it. We want a fresh Tomcat
for each and every test case. This way, a failed test does not have repercussions on the subsequent tests (e.g. session information, memory leaks);</p>

<p>```java Start the embedded Tomcat instance and add a web application
@Before
public void setup() throws Throwable {</p>

<pre><code>...
mTomcat.start();
</code></pre>

<p>}
```</p>

<p>If necessary, the actual port on which Tomcat has been started can be retrieved using the following snippet.
```java
protected int getTomcatPort() {</p>

<pre><code>return mTomcat.getConnector().getLocalPort();
</code></pre>

<p>}
```</p>

<p>Finally, after the test, the Tomcat instance is stopped and destroyed clearing the way for the next test.</p>

<h2>Stopping Tomcat</h2>

<p>```java
@After
public final void teardown() throws Throwable {</p>

<pre><code>if (mTomcat.getServer() != null
        &amp;&amp; mTomcat.getServer().getState() != LifecycleState.DESTROYED) {
    if (mTomcat.getServer().getState() != LifecycleState.STOPPED) {
            mTomcat.stop();
    }
    mTomcat.destroy();
}
</code></pre>

<p>}
```</p>

<h2>Conclusion</h2>

<p>In this post, we have seen how to start an embedded version of Tomcat into a JUnit fixture.
The examples used in this blog are to be found in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project on <a href="http://code.google.com">Google code hosting</a>.</p>
]]></content>
  </entry>
  
</feed>
