<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: OR Mapping | Steve Hostettler]]></title>
  <link href="http://hostettler.github.io/blog/categories/or-mapping/atom.xml" rel="self"/>
  <link href="http://hostettler.github.io/"/>
  <updated>2014-05-13T21:59:46+02:00</updated>
  <id>http://hostettler.github.io/</id>
  <author>
    <name><![CDATA[Steve Hostettler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[One to One relations in JPA 2.0]]></title>
    <link href="http://hostettler.github.io/blog/2012/03/22/one-to-one-relations-in-jpa-2-dot-0/"/>
    <updated>2012-03-22T10:41:00+01:00</updated>
    <id>http://hostettler.github.io/blog/2012/03/22/one-to-one-relations-in-jpa-2-dot-0</id>
    <content type="html"><![CDATA[<p>Recently I came across the need to map a one 2 one relationship from the object model to the database using JPA 2.0.
The case was pretty simple as the database was nicely organized but it raised the question: what if? What if I have to deal to a legacy system or a database administrator that has to follow strict company rules. Other reasons such as security or performances may interfere with simple designs. Hence, I had a look to the diverse ways to map a one 2 one relationship. I probably forgot several cases so please do not hesitate to discuss them in the comments.</p>

<p>A one to one relationship consider that the objects involved in the relation are highly dependent. In Object Orientation, this corresponds to the an aggregation or a composition. In a relational model, the data can be either:</p>

<ol>
<li>in the same table,</li>
<li>split over two (or more) tables (one per object) and linked by a foreign key, or</li>
<li>split over two (or more) tables and linked by a join table.</li>
</ol>


<p>The rest of the articles these describes different situations. Please note that for the sake of the explanation, I explicitly map all the fields even if most of the time the default mapping policy would work.</p>

<h2>Data in the same class: Embedded class</h2>

<p>This is especially useful for legacy code where the database design is a bit to flat for your taste.
The following figure presents the concept of an embedded class. The class <code>Address</code> is embedded in the class <code>Student</code>.
The idea is that <code>Address</code> is an entity per se, it exists only in the context of the class <code>Student</code>.</p>

<p><span class='caption-wrapper center'><img class='caption' src='/figures/one2oneVariante1.png' width='' height='' alt='One 2 One relations as an embedded class' title='One 2 One relations as an embedded class'><span class='caption-text'>One 2 One relations as an embedded class</span></span></p>

<p>To declare a embedded class, the class itself must be annotated with <code>@Embeddable</code> and its reference must be annotated with
<code>@Embedded</code>.</p>

<p>```java A embeddable class
@Embeddable
public class Address implements Serializable {</p>

<pre><code>...
@Column(name = "NUMBER")
private String number;

@Column(name = "STREET")
private String street;
...
</code></pre>

<p>}
```</p>

<p><code>@Embedded</code> and <code>@Basic</code> cannot be used together. Therefore, if required, lazy fetching must be declared field by field in the embedded class. Remember that outside of a JEE container,  the actual behavior of lazy loading on <code>@Basic</code> and <code>@OneToOne</code> depend on the actual implementation. Eclipse link, for instance, does not perform lazy loading by default on <code>@Basic</code>, <code>@OneToOne</code>, and <code>@ManyToOne</code> mappings. For more detail, please refer to the <a href="http://wiki.eclipse.org/Using_EclipseLink_JPA_Extensions_%28ELUG%29#What_You_May_Need_to_Know_About_EclipseLink_JPA_Lazy_Loading">Eclipse-link specification</a>.</p>

<p>```java The class Address is embedded into a Student
@Entity
@Table(name = "STUDENTS")
public class Student implements Serializable {</p>

<pre><code>...

@Id
@Column(name = "ID")
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long mId;

...

@Embedded
private Address mAddress;

...
</code></pre>

<p>}
```</p>

<p>The following SQL statement shows the code generated by the previous mapping.</p>

<p>```sql SQL code generated according to the previous mapping
SELECT  ID, FIRST_NAME, PHONE_NUMBER, BIRTH_DATE, LAST_NAME, NUMBER,</p>

<pre><code>    CITY, STREET, POSTAL_CODE 
</code></pre>

<p>  FROM  STUDENTS
```</p>

<h2>Data in different classes: Secondary Tables</h2>

<p>In the second scenario, the OO model is composed on only one class but the relational model is split over several tables.</p>

<h3>The foreign key is in the secondary table</h3>

<p><span class='caption-wrapper center'><img class='caption' src='/figures/one2oneVariante2.png' width='' height='' alt='Data is in different tables with the foreign key in the secondary table' title='Data is in different tables with the foreign key in the secondary table'><span class='caption-text'>Data is in different tables with the foreign key in the secondary table</span></span></p>

<p>In this case, the concepts of secondary tables is very useful. A secondary table is basically a table that hosts
important data that are one to one related to the data of the primary table.
Unlike the first case, a join is required and thus a key mapping is required.
In the following mapping, the secondary table <code>PICTURES</code> is mapped using its <code>STUDENT_ID</code> field to the <code>ID</code> field
of the main table.</p>

<p>```java Mapping of the Student entity
@SecondaryTable(name = "PICTURES",</p>

<pre><code>pkJoinColumns = @PrimaryKeyJoinColumn(name = "STUDENT_ID", 
    referencedColumnName = "ID"))
</code></pre>

<p>public class Student implements Serializable {</p>

<pre><code>...
@Id
@Column(name = "ID")
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long mId;

/** A picture of the student. */
@Lob
@Basic(optional = true, fetch = FetchType.EAGER)
@Column(table = "PICTURES", name = "PICTURE", nullable = true)
private byte[] mPicture;
...
</code></pre>

<p><code>`
The following SQL statement shows the code generated by the previous mapping.
It joins the two tables according to the</code>@PrimaryKeyJoinColumn`` annotation.</p>

<p>```sql SQL code generated by the previous mapping
SELECT  t0.ID, t1.STUDENT_ID, t1.PICTURE, t0.FIRST_NAME, t0.PHONE_NUMBER, t0.BIRTH_DATE,</p>

<pre><code>    t0.LAST_NAME, t0.NUMBER, t0.CITY, t0.STREET, t0.POSTAL_CODE 
</code></pre>

<p>  FROM  STUDENTS t0, PICTURES t1
 WHERE  (t1.STUDENT_ID = t0.ID)</p>

<p>```</p>

<h3>The foreign key is in the host table</h3>

<p>Similarly to the previous case, the data is split over several tables. The difference lies in the foreign key position.
Here the foreign key is hosted in the primary table.
<span class='caption-wrapper center'><img class='caption' src='/figures/one2oneVariante3.png' width='' height='' alt='Data is in different tables with the foreign key in the primary/host table' title='Data is in different tables with the foreign key in the primary/host table'><span class='caption-text'>Data is in different tables with the foreign key in the primary/host table</span></span></p>

<p>From a mapping point of view, it is very similar to the previous case. Indeed only the key column names have to be changed
to reflect the organization.</p>

<p>```java Mapping of the Student entity
@SecondaryTable(name = "PICTURES",</p>

<pre><code>pkJoinColumns = @PrimaryKeyJoinColumn(name = "PICTURE_ID", 
    referencedColumnName = "PICTURE_ID"))
</code></pre>

<p>public class Student implements Serializable {
```</p>

<p>The following SQL statement shows the code generated by the previous mapping.
Again, the data are joined according to the content of the <code>@PrimaryKeyJoinColumn</code> annotation.</p>

<p>```sql SQL code generated by the previous mapping
SELECT  t0.ID, t0.PICTURE_ID, t1.PICTURE_ID, t1.PICTURE, t0.FIRST_NAME, t0.PHONE_NUMBER, t0.BIRTH_DATE,</p>

<pre><code>    t0.LAST_NAME,t0.NUMBER, t0.CITY, t0.STREET, t0.POSTAL_CODE 
</code></pre>

<p>  FROM  STUDENTS t0, PICTURES t1
 WHERE  (t1.PICTURE_ID = t0.PICTURE_ID)
```</p>

<h2>First and second class JPA citizens</h2>

<p>In the previous examples, the table <code>PICTURES</code> does not have a business existence in itself. It is a secondary table because its data only have meaning in relation to the data of the primary table. Sometimes, we may want to treat the second objects as first class JPA citizens and thus we must put the <code>@Entity</code> annotation on it. In this case, we have to use the <code>@OneToOne</code> annotation for the mapping. Unlike the previous mappings, <code>@OneToOne</code> enable bidirectional mapping.</p>

<p>In the last example, the tables <code>STUDENTS</code> and  <code>BADGES</code> have a one to one relationship modeled with a foreign in the <code>BADGES</code> table to the <code>STUDENTS</code> table. In this case, the owning side is the <code>Badge</code> entity has it contains the foreign key.</p>

<p>As mentioned before, the class <code>Badge</code> is now an entity has it has a business existence without <code>Student</code>.  The interesting part is the <code>@JoinColumn</code> annotation that specifies the local column that is the foreign key (<code>STUDENT_ID</code>) as well as to which column of the foreign table its corresponds (<code>ID</code>).</p>

<p>```java Mapping of the Badge entity
@Entity
@Table(name = "BADGES")
public class Badge implements Serializable {</p>

<pre><code>...

@Id
@Column(name = "ID")
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long mId;

@Column(name = "SECURITY_LEVEL")
private Long mSecurityLevel;

@OneToOne
@JoinColumn(name = "STUDENT_ID", referencedColumnName = "ID")
private Student mStudent;

...
</code></pre>

<p>```</p>

<p>As we want the other side to be aware of the relation (bidirectional), it is required to add the <code>mappedBy</code> attribute to the <code>@OneToOne</code> annotation. This attribute references the (Java) property in the entity that is the owner of the relationship.</p>

<p>```java  Mapping of the Student entity
@Entity
...
public class Student implements Serializable {</p>

<pre><code>...
@Id
@Column(name = "ID")
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long mId;


/** The Student's badge. */
@OneToOne(mappedBy = "mStudent")
private Badge mBadge;
...
</code></pre>

<p>}
```</p>

<p>Using the previous mapping, JPA 2.0 produces the following SQL statements to load the Student object.
```sql
SELECT t0.ID, t1.STUDENT_ID, t1.PICTURE, t0.FIRST_NAME, t0.PHONE_NUMBER,</p>

<pre><code>   t0.BIRTH_DATE, t0.LAST_NAME, t0.NUMBER, t0.CITY, t0.STREET, 
   t0.POSTAL_CODE 
</code></pre>

<p>  FROM STUDENTS t0, PICTURES t1
 WHERE (t1.STUDENT_ID = t0.ID)</p>

<p>SELECT ID, SECURITY_LEVEL, STUDENT_ID
  FROM BADGES
 WHERE (STUDENT_ID = ?)
```</p>

<h2>Conclusion</h2>

<p>JPA 2.0 offers many way to represent one to one relationships. This flexibility allows to handle many different scenarios that may happen when integrating legacy databases. The examples used in this blog are to be found in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project on <a href="http://code.google.com">Google code hosting</a>.</p>
]]></content>
  </entry>
  
</feed>
