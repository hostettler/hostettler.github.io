<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Weld | Steve Hostettler]]></title>
  <link href="http://hostettler.github.io/blog/categories/weld/atom.xml" rel="self"/>
  <link href="http://hostettler.github.io/"/>
  <updated>2015-01-18T09:47:14+01:00</updated>
  <id>http://hostettler.github.io/</id>
  <author>
    <name><![CDATA[Steve Hostettler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Simulate CDI Scopes and Injection in Java SE.]]></title>
    <link href="http://hostettler.github.io/blog/2012/04/02/how-to-test-a-jsf-named-bean/"/>
    <updated>2012-04-02T21:37:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/04/02/how-to-test-a-jsf-named-bean</id>
    <content type="html"><![CDATA[<p>Unit testing managed beans is difficult outside of a container. Managed beans heavily rely on the notions of scopes and injection that do not exist outside of a container. In JEE6, both are handled by CDI (Context Dependency Injection).
<a href="http://www.jboss.org/arquillian.html">Arquillian</a> is a powerful solution to this problem. Nevertheless, sometimes for technical or even for political reasons, it is not possible to add a new component to the existing stack.
While searching for alternatives, I came across several interesting articles (<a href="http://www.jtips.info/index.php?title=WeldSE/Scopes">here</a>, <a href="http://objectopia.com/2011/05/29/weld-junit-4-runner/">here</a> and <a href="http://danhaywood.com/2010/08/12/simulating-cdis-session-and-request-scope-in-a-j2se-app/">here</a>) that explain how to simulate such features in unit tests.</p>

<p>This post aims at consolidating these articles for Weld 1.1.5 and JUnit 4.5.
The following example is part of a Demo project that I use to teach the JEE stack that is located on Google Code Hosting and <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a></p>

<p>The following snippet presents a unit test of a managed bean. The bean to test (and all its dependencies) is injected in the test. As you can see the test is simple and straightforward.
The injected scopes (Conversation in this case) can be used during the test to setup a particular case.</p>

<p>```java Unit testing of the ManageStudentRegistration managed bean
@RunWith(WeldJUnit4Runner.class)
public class ManageStudentRegistrationTest {</p>

<pre><code>/** Service injected by the Weld container. */
@Inject
private ManageStudentRegistration mManageStudentRegistration;

/** A conversation for the test. */
@Inject
private Conversation mConversation;

@Test
public void testPieChartCreation() {
    PieChartModel model = this.mManageStudentRegistration.getPieModel();
    Assert.assertNotNull(model);
    Assert.assertEquals(4, model.getData().size());
}

@Test
public void toRegistrationTest() {
    this.mConversation.begin("ConversationId");
    Assert.assertEquals("register", mManageStudentRegistration.toRegistration());
}
</code></pre>

<p>}
```</p>

<p>The fist step is to enable CDI injection in unit tests. To that end, we extends the <code>BlockJUnit4ClassRunner</code> that is responsible for creating a Test case.
The constructor simply initializes the Weld container. Finally, we override the
test creation. Instead of directly invoking the constructor of the test class, we ask Weld to instantiate it (line 25). This will inject all dependencies into the test object. In our case, it will create  the manager bean and its dependencies.</p>

<p>```java
public class WeldJUnit4Runner extends BlockJUnit4ClassRunner {</p>

<pre><code>/** The test class to run. */
private final Class&lt;?&gt; mKlass;
/** Weld infrastructure. */
private final Weld weld;
/** The container itself. */
private final WeldContainer container;

/**
 * Runs the class passed as a parameter within the container.
 * @param klass to run
 * @throws InitializationError if anything goes wrong.
 */
public WeldJUnit4Runner(final Class&lt;Object&gt; klass) throws InitializationError {
    super(klass);
    this.mKlass = klass;
    this.weld = new Weld();
    this.container = weld.initialize();
}


@Override
protected Object createTest() throws Exception {
    final Object test = container.instance().select(mKlass).get();
    return test;
}
</code></pre>

<p>}
```</p>

<p>Remember to declare a <code>META-INF/beans.xml</code> file in the test resources in order to provide
mock implementations. In this case, we enable the alternative <code>StudentServiceMockImpl</code> that is used by the managed bean that is under test.</p>

<p>```xml META-INF/beans.xml file used for the unit tests.
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</p>

<pre><code>xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/beans_1_0.xsd"&gt;
&lt;alternatives&gt;
    &lt;class&gt;ch.demo.business.service.mock.StudentServiceMockImpl&lt;/class&gt;
&lt;/alternatives&gt;
</code></pre>

<p></beans>
```</p>

<p>Until there, the dependency injection does not manage the scopes that may be used in managed bean. To that end, we must add an <a href="http://docs.jboss.org/weld/reference/latest/en-US/html/extend.html">extension</a> to Weld. Extensions are powerful mechanisms to tweak the container behavior. In this case, we want to add the missing scopes. This is done in the following snippet. It listens to the <code>AfterDeploymentValidation</code> event that occurs after the configuration as been validated but before context creation. Methods <code>afterDeployment</code> creates a map for each scope and associates it.
```java
package org.jboss.weld.manager; // required for visibility to BeanManagerImpl#getContexts()
...
/<em>*
 * Taken from http://www.jtips.info/index.php?title=WeldSE/Scopes,
 * it simulates request and session scopes outside of an application server.
 </em>/
public class WeldServletScopesSupportForSe implements Extension {</p>

<pre><code>/** {@inheritDoc} */
public void afterDeployment(@Observes final AfterDeploymentValidation event, 
                final BeanManager beanManager) {

    Map&lt;String, Object&gt; sessionMap = new HashMap&lt;String, Object&gt;();
    activateContext(beanManager, SessionScoped.class, sessionMap);

    Map&lt;String, Object&gt; requestMap = new HashMap&lt;String, Object&gt;();
    activateContext(beanManager, RequestScoped.class, requestMap);

    activateContext(beanManager, ConversationScoped.class, 
            new MutableBoundRequest(requestMap, sessionMap));
}

/**
 * Activates a context for a given manager.
 * @param beanManager in which the context is activated
 * @param cls the class that represents the scope
 * @param storage in which to put the scoped values
 * @param &lt;S&gt; the type of the storage
 */
private &lt;S&gt; void activateContext(final BeanManager beanManager,
            final Class&lt;? extends Annotation&gt; cls, final S storage) {
    BeanManagerImpl beanManagerImpl = (BeanManagerImpl) beanManager;
    @SuppressWarnings("unchecked")
    AbstractBoundContext&lt;S&gt; context = 
        (AbstractBoundContext&lt;S&gt;) beanManagerImpl.getContexts().get(cls).get(0);

    context.associate(storage);
    context.activate();
}
</code></pre>

<p>}
```</p>

<p>To register and activate a CDI extension, a file that contains the extension class name must be present and named <code>META-INF/services/javax.enterprise.inject.spi.Extension</code>.
<code>java META-INF/services/javax.enterprise.inject.spi.Extension
org.jboss.weld.manager.WeldServletScopesSupportForSe
</code></p>

<h2>Conclusion</h2>

<p>Testing the JEE6 outside of the container is easier and easier. Long gone are the days of the EJB 2.1 untestability.
Nevertheless, not everything is simple and we still have to do some tricks to get it working.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On JEE 6 Webapps Startup Time]]></title>
    <link href="http://hostettler.github.io/blog/2012/03/25/improve-jsf-applications-startup-time/"/>
    <updated>2012-03-25T23:20:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/03/25/improve-jsf-applications-startup-time</id>
    <content type="html"><![CDATA[<p>While working on Tomcat 7 embedded to automate my integration tests, I realized that my integration tests wasted much of the time in starting/stopping the server. Even if I do not start the integration tests as often as the unit tests, it becomes rapidly irritating. Furthermore, during development I tend to restart the server a couple of times per hour, especially at the beginning of the project. Sure hot deployment helps, but it is not always enough.</p>

<p>On my Mac Book Pro, a cold start took around 10s. Interestingly enough,  an empty Tomcat startups in less than a second. The problem comes from the fact that Tomcat 7 scans the classpath to find out annotations that declare Servlets using the <code>@WebServlet</code>. This, even if you do not use that feature. Don't get me wrong, not having to configure XML is cool but I am not ready to pay such a high price for it. Especially as the only servlet I use, is the JSF one.</p>

<h2>Where do we start from?</h2>

<p>For these tests, I use a JEE6 application with JSF, Weld and JPA (no EJBs) that runs under Tomcat. <br/>
This is a demo application called <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> that I use to teach JEE6.
A mentioned previously, a cold start (without tuning anything) requires around 10s on my Mac Book Pro Intel Core i7 with 8Gb RAM : <code>INFO: Server startup in 9992 ms</code></p>

<h2>Step 1: Avoid looking for <code>@WebSerlet</code> and co.</h2>

<p>By default, Tomcat 7 (along with the Servlet 3.0 specification) scans the classpath to look for classes that are annotated <code>@WebServlet</code>,<code>@WebServletContextListener</code>, <code>@ServletFilter</code>, or <code>@InitParamJSF</code>.  It is a nice feature as you do not have to specify the faces servlet anymore.
However, it comes at a price: depending of the classpath this can be very long.
To solve this issues, simple add the <code>metadata-complete="true"</code> to the <code>web-app</code> element of our <code>WEB-INF/web-xml</code> attribute to avoid scanning the classpath.</p>

<p>```xml web.xml's webapp element
&lt;web-app metadata-complete="true"</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee"
xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
id="MyWebApp" version="3.0"&gt;
</code></pre>

<p>```</p>

<p>Obviously, as it is no more automatically discovered, we have  to manually add the faces servlet to the context:</p>

<p>```xml Add the faces servlet</p>

<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/faces/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>

<p>```</p>

<p>Using these modifications in <code>web.xml</code>, the startup time came down to around 4.5 seconds:
<code>INFO: Server startup in 4404 ms</code></p>

<h2>Step 2: Avoid looking for <code>@ManagedBean</code> and co.</h2>

<p>Similarly, the is a similar feature in JSF 2.0. By default, the JSF implementation looks for classes annotated with
As I use Weld and its <code>@Named</code>, <code>@SessionScoped</code>, and so on, I can disable this feature in JSF.
<code>xml faces-config.xml annotated with metadata-complete="true"
&lt;faces-config xmlns="http://java.sun.com/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-facesconfig_2_0.xsd"
   version="2.0"  metadata-complete="true"&gt;
</code></p>

<p>Using this modification in <code>faces-config.xml</code>, the startup time came down to around 3.7 seconds:
<code>INFO: Server startup in 3730 ms</code></p>

<h2>Step 3: Limiting Weld's scanning</h2>

<p>Finally, I would like to keep Weld scanning to discover the <code>@Named</code>, <code>@Inject</code>, and other Weld annotations but I would like to limit it to my a subset of the classes of the jar. To that end simply add <code>weld:scan</code> directive and include a pattern with packages to scan.</p>

<p>```
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://java.sun.com/xml/ns/javaee"</p>

<pre><code>    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xmlns:weld="http://jboss.org/schema/weld/beans" 
    xsi:schemaLocation="
       http://java.sun.com/xml/ns/javaee http://jboss.org/schema/cdi/beans_1_0.xsd
       http://jboss.org/schema/weld/beans http://jboss.org/schema/weld/beans_1_1.xsd"&gt;
</code></pre>

<p>&lt;weld:scan></p>

<pre><code>&lt;weld:include pattern="ch.demo.*"/&gt;
</code></pre>

<p>&lt;/weld:scan>
```</p>

<p>Using this modification in <code>beans.xml</code>, the startup time came down to around 3.3 seconds:
<code>INFO: Server startup in 3312 ms</code></p>

<p>To conclude, using these minor modifications I divided the startup time by three. This is very useful during development and integration tests when the server is started and stopped many times.</p>
]]></content>
  </entry>
  
</feed>
