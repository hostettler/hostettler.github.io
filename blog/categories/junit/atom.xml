<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JUnit | Steve Hostettler]]></title>
  <link href="http://hostettler.github.io/blog/categories/junit/atom.xml" rel="self"/>
  <link href="http://hostettler.github.io/"/>
  <updated>2015-01-18T11:31:06+01:00</updated>
  <id>http://hostettler.github.io/</id>
  <author>
    <name><![CDATA[Steve Hostettler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Selenium for Web Integration Testing]]></title>
    <link href="http://hostettler.github.io/blog/2012/04/16/using-selenium-for-web-integration-testing/"/>
    <updated>2012-04-16T18:57:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/04/16/using-selenium-for-web-integration-testing</id>
    <content type="html"><![CDATA[<p>Following up on my previous posts (<a href="/blog/2012/04/09/embedded-jee-web-application-integration-testing-using-tomcat-7/">here</a>
and <a href="/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap/">here</a> about integration testing
of JEE web applications, I will present how to write smoke tests using Selenium. The idea is to
detect whether important regressions have been introduced. This is especially useful to detect
configuration and navigation problems. I've split the test in three parts:</p>

<ol>
<li>starting and stopping the container. Embedded Tomcat 7 in our case. This is described
<a href="/blog/2012/04/09/embedded-jee-web-application-integration-testing-using-tomcat-7">here</a>;</li>
<li>building the WAR file to test. To that end, you can look at this
<a href="/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap">post</a> that describes how to
build such a test archive using Shrinkwrap;</li>
<li>finally, we must build the test case. This is the goal of this post.</li>
</ol>


<p>Testing a use case requires to be able to:</p>

<ol>
<li>get a page at a given URL;</li>
<li>input test data into the web elements;</li>
<li>assert whether the server answers as expected.</li>
</ol>


<p>Selenium provides an easy API to fetch URLs
As these are smoke tests, using the <code>HtmlUnitDriver</code> instead of a specific browser is sufficient.
We do not want to detect minor display problems but rather important functional problems.</p>

<p>Selenium has many different drivers for many different browser. The problem is that it opens the
browser in a new window. I prefer to have the continuous integration running headless.</p>

<p>The following dependencies are required to run the tests.</p>

<p>```xml Maven dependencies
<dependency></p>

<pre><code>&lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;
&lt;artifactId&gt;selenium-java&lt;/artifactId&gt;
&lt;version&gt;2.20.0&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;net.sourceforge.htmlunit&lt;/groupId&gt;
&lt;artifactId&gt;htmlunit&lt;/artifactId&gt;
&lt;version&gt;2.9&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<p>First, let's build a new headless driver. This object simulates the browser. It manages the HTTP part as
well as parsing the HTML and the javascript code that is returned.</p>

<p><code>java
WebDriver driver = new HtmlUnitDriver();
</code></p>

<p>The next step is to ask the driver to load the home page that we want to test. For
convenience, in my previous posts I defined a method that returns the current Tomcat port and the
application context.</p>

<p><code>java
driver.get("http://localhost:" + getTomcatPort() + "/" + getApplicationId());
</code></p>

<p>Let's assume that the home page redirects to a login page that has two text boxes (respectively
called <code>username</code> and password). The following snippet uses XPATH expressions to locate web elements.
First, it locates a HTML element of type <code>input</code> that has an
attribute  <code>id</code> set to <code>username</code>. If this web element is not present, the driver will raise an exception.
This allows to easily detect whether a widget has been accidentally removed.</p>

<p><code>java
WebElement username = driver.findElement(By.xpath("//input[contains(@id,'username')]"));
</code></p>

<p>Now we can interact with the previous element. For instance, to simulate a user that types in its username (<code>admin</code>).
<code>java
username.sendKeys("admin");
</code></p>

<p>After that, Let's do the same for the web element called <code>password</code>.
<code>java
WebElement password = driver.findElement(By.xpath("//input[contains(@id,'password')]"));
password.sendKeys("admin");
</code></p>

<p>Finally, we locate a button called <code>login</code>and we simulate a click on it.</p>

<p><code>java
WebElement login = driver.findElement(By.xpath("//button[contains(@id,'login')]"));
login.click();
</code></p>

<p>On successful login, our example redirects to a page that contains a list of students.
The following assertion checks that the string <code>Student list</code> exists somewhere is the returned
HTML source code.</p>

<p><code>java
Assert.assertTrue(driver.getPageSource().contains("Student list"));
</code></p>

<p>With this approach, it is also very easy to do trivial security testing. For instance, let's check that
the application redirects (or forwards) the user to the login page upon unsuccessful login.
<code>java
WebElement username = driver.findElement(By.xpath("//input[contains(@id,'username')]"));
username.sendKeys("foo");
WebElement password = driver.findElement(By.xpath("//input[contains(@id,'password')]"));
password.sendKeys("foo");
WebElement login = driver.findElement(By.xpath("//button[contains(@id,'login')]"));
login.click();
Assert.assertTrue(driver.getPageSource().contains("username"));
Assert.assertTrue(driver.getPageSource().contains("password"));
Assert.assertTrue(driver.getPageSource().contains("login"));
</code></p>

<h2>Conclusion</h2>

<p>In this post, we have seen how to write smoke integration tests with Selenium. This is especially
useful to detect whether an important functionality has been hindered. For instance, a change in the
navigation or a unexpected change of the status (availability, visibility) of one the buttons or web elements.
I recommend implementing the three or four major scenarios with this technique. This is usually enough to
detect major problems. The examples used in this blog are to be found in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project on <a href="http://code.google.com">Google code hosting</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Embedded Web Application Integration Testing Using Tomcat 7 and JUnit]]></title>
    <link href="http://hostettler.github.io/blog/2012/04/09/embedded-jee-web-application-integration-testing-using-tomcat-7/"/>
    <updated>2012-04-09T14:39:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/04/09/embedded-jee-web-application-integration-testing-using-tomcat-7</id>
    <content type="html"><![CDATA[<p>To follow up on my previous post about <a href="/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap/">how to programmatically build a web archive</a>, I propose to look at how to deploy this archive in a Tomcat instance that is embedded into a JUnit test.</p>

<p>As usual, the presented snippets are available in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> application. I will first look at the dependencies, then I will show how to configure Tomcat and finally how to start and stop the embedded instance.</p>

<p>The first dependency is the embedded Tomcat core component. JULI which stands for Java Utility Logging Implementation that is the container extension of common logging. The ECJ compiler and JASPER are required to handle JSPs. Of course all these dependencies are scoped to test only.</p>

<h2>The dependencies</h2>

<p>```xml Maven dependencies necessary to start an embedded Tomcat instance into JUnit tests.
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
&lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;
&lt;version&gt;7.0.26&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
&lt;artifactId&gt;tomcat-embed-logging-juli&lt;/artifactId&gt;
&lt;version&gt;7.0.26&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;org.eclipse.jdt.core.compiler&lt;/groupId&gt;
&lt;artifactId&gt;ecj&lt;/artifactId&gt;
&lt;version&gt;3.7.1&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
&lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
&lt;version&gt;7.0.26&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;junit&lt;/groupId&gt;
&lt;artifactId&gt;junit&lt;/artifactId&gt;
&lt;version&gt;4.10&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<h2>Configuring Tomcat</h2>

<p>The following snippet prepares the embedded instance. The static member <code>mTomcat</code> references a new instance of Tomcat. As Tomcat still requires a file system to work, a temporary directory is used to put all the temporary files. To that end, we use the <code>java.io.tmpdir</code> java property.
These variables are shared among the test cases.</p>

<p>```java Shared static variables</p>

<p>/<strong> The tomcat instance. */
private Tomcat mTomcat;
/</strong> The temporary directory in which Tomcat and the app are deployed. */
private String mWorkingDir = System.getProperty("java.io.tmpdir");
```</p>

<p>As we want to use the same Tomcat configuration among all test cases, the initialization is put in a method annotated with <code>@Before</code>. First, the method sets the port to <code>0</code>. This tells the engine to choose the port to run on by itself.  This is especially useful to avoid  starting the embedded Tomcat on a already used port as <code>8080</code> for instance.
Then the base directory is set <code>mTomcat.setBaseDir()</code> to the temporary directory. Without doing that, Tomcat would start in the current directory. The rest of the method configures the way WAR are managed by the engine.</p>

<p>```java Configuration of the embedded Tomcat instance
@Before
public void setup() throws Throwable {</p>

<pre><code>mTomcat = new Tomcat();
mTomcat.setPort(0);
mTomcat.setBaseDir(mWorkingDir);
mTomcat.getHost().setAppBase(mWorkingDir);
mTomcat.getHost().setAutoDeploy(true);
mTomcat.getHost().setDeployOnStartup(true);
...
</code></pre>

<p>}
```</p>

<p>The rest of the method builds a reference to a directory (based into the temporary directory) that contains the web application. This directory is deleted if it exists to ensure redeployment of the WAR. Finally, the WAR built as explained <a href="/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap/">there</a> is exported into the temporary directory.</p>

<p>Finally, the web application is added to the Tomcat instance. More specifically, a path
exploded version <code>webApp.getAbsolutePath()</code> of the WAR is linked to a context <code>contextPath</code>.</p>

<p>```java Cleaning and preparing the web application deployment.
@Before
public void setup() throws Throwable {</p>

<pre><code>...
String contextPath = "/" + getApplicationId();
File webApp = new File(mWorkingDir, getApplicationId());
File oldWebApp = new File(webApp.getAbsolutePath());
FileUtils.deleteDirectory(oldWebApp);
new ZipExporterImpl(createWebArchive()).exportTo(new File(mWorkingDir + "/" + getApplicationId() + ".war"),
        true);
mTomcat.addWebapp(mTomcat.getHost(), contextPath, webApp.getAbsolutePath());    
</code></pre>

<p>}
```</p>

<h2>Starting Tomcat</h2>

<p>Now that Tomcat has been configured, the next step is to start it. We want a fresh Tomcat
for each and every test case. This way, a failed test does not have repercussions on the subsequent tests (e.g. session information, memory leaks);</p>

<p>```java Start the embedded Tomcat instance and add a web application
@Before
public void setup() throws Throwable {</p>

<pre><code>...
mTomcat.start();
</code></pre>

<p>}
```</p>

<p>If necessary, the actual port on which Tomcat has been started can be retrieved using the following snippet.
```java
protected int getTomcatPort() {</p>

<pre><code>return mTomcat.getConnector().getLocalPort();
</code></pre>

<p>}
```</p>

<p>Finally, after the test, the Tomcat instance is stopped and destroyed clearing the way for the next test.</p>

<h2>Stopping Tomcat</h2>

<p>```java
@After
public final void teardown() throws Throwable {</p>

<pre><code>if (mTomcat.getServer() != null
        &amp;&amp; mTomcat.getServer().getState() != LifecycleState.DESTROYED) {
    if (mTomcat.getServer().getState() != LifecycleState.STOPPED) {
            mTomcat.stop();
    }
    mTomcat.destroy();
}
</code></pre>

<p>}
```</p>

<h2>Conclusion</h2>

<p>In this post, we have seen how to start an embedded version of Tomcat into a JUnit fixture.
The examples used in this blog are to be found in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project on <a href="http://code.google.com">Google code hosting</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Simulate CDI Scopes and Injection in Java SE.]]></title>
    <link href="http://hostettler.github.io/blog/2012/04/02/how-to-test-a-jsf-named-bean/"/>
    <updated>2012-04-02T21:37:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/04/02/how-to-test-a-jsf-named-bean</id>
    <content type="html"><![CDATA[<p>Unit testing managed beans is difficult outside of a container. Managed beans heavily rely on the notions of scopes and injection that do not exist outside of a container. In JEE6, both are handled by CDI (Context Dependency Injection).
<a href="http://www.jboss.org/arquillian.html">Arquillian</a> is a powerful solution to this problem. Nevertheless, sometimes for technical or even for political reasons, it is not possible to add a new component to the existing stack.
While searching for alternatives, I came across several interesting articles (<a href="http://www.jtips.info/index.php?title=WeldSE/Scopes">here</a>, <a href="http://objectopia.com/2011/05/29/weld-junit-4-runner/">here</a> and <a href="http://danhaywood.com/2010/08/12/simulating-cdis-session-and-request-scope-in-a-j2se-app/">here</a>) that explain how to simulate such features in unit tests.</p>

<p>This post aims at consolidating these articles for Weld 1.1.5 and JUnit 4.5.
The following example is part of a Demo project that I use to teach the JEE stack that is located on Google Code Hosting and <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a></p>

<p>The following snippet presents a unit test of a managed bean. The bean to test (and all its dependencies) is injected in the test. As you can see the test is simple and straightforward.
The injected scopes (Conversation in this case) can be used during the test to setup a particular case.</p>

<p>```java Unit testing of the ManageStudentRegistration managed bean
@RunWith(WeldJUnit4Runner.class)
public class ManageStudentRegistrationTest {</p>

<pre><code>/** Service injected by the Weld container. */
@Inject
private ManageStudentRegistration mManageStudentRegistration;

/** A conversation for the test. */
@Inject
private Conversation mConversation;

@Test
public void testPieChartCreation() {
    PieChartModel model = this.mManageStudentRegistration.getPieModel();
    Assert.assertNotNull(model);
    Assert.assertEquals(4, model.getData().size());
}

@Test
public void toRegistrationTest() {
    this.mConversation.begin("ConversationId");
    Assert.assertEquals("register", mManageStudentRegistration.toRegistration());
}
</code></pre>

<p>}
```</p>

<p>The fist step is to enable CDI injection in unit tests. To that end, we extends the <code>BlockJUnit4ClassRunner</code> that is responsible for creating a Test case.
The constructor simply initializes the Weld container. Finally, we override the
test creation. Instead of directly invoking the constructor of the test class, we ask Weld to instantiate it (line 25). This will inject all dependencies into the test object. In our case, it will create  the manager bean and its dependencies.</p>

<p>```java
public class WeldJUnit4Runner extends BlockJUnit4ClassRunner {</p>

<pre><code>/** The test class to run. */
private final Class&lt;?&gt; mKlass;
/** Weld infrastructure. */
private final Weld weld;
/** The container itself. */
private final WeldContainer container;

/**
 * Runs the class passed as a parameter within the container.
 * @param klass to run
 * @throws InitializationError if anything goes wrong.
 */
public WeldJUnit4Runner(final Class&lt;Object&gt; klass) throws InitializationError {
    super(klass);
    this.mKlass = klass;
    this.weld = new Weld();
    this.container = weld.initialize();
}


@Override
protected Object createTest() throws Exception {
    final Object test = container.instance().select(mKlass).get();
    return test;
}
</code></pre>

<p>}
```</p>

<p>Remember to declare a <code>META-INF/beans.xml</code> file in the test resources in order to provide
mock implementations. In this case, we enable the alternative <code>StudentServiceMockImpl</code> that is used by the managed bean that is under test.</p>

<p>```xml META-INF/beans.xml file used for the unit tests.
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</p>

<pre><code>xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/beans_1_0.xsd"&gt;
&lt;alternatives&gt;
    &lt;class&gt;ch.demo.business.service.mock.StudentServiceMockImpl&lt;/class&gt;
&lt;/alternatives&gt;
</code></pre>

<p></beans>
```</p>

<p>Until there, the dependency injection does not manage the scopes that may be used in managed bean. To that end, we must add an <a href="http://docs.jboss.org/weld/reference/latest/en-US/html/extend.html">extension</a> to Weld. Extensions are powerful mechanisms to tweak the container behavior. In this case, we want to add the missing scopes. This is done in the following snippet. It listens to the <code>AfterDeploymentValidation</code> event that occurs after the configuration as been validated but before context creation. Methods <code>afterDeployment</code> creates a map for each scope and associates it.
```java
package org.jboss.weld.manager; // required for visibility to BeanManagerImpl#getContexts()
...
/<em>*
 * Taken from http://www.jtips.info/index.php?title=WeldSE/Scopes,
 * it simulates request and session scopes outside of an application server.
 </em>/
public class WeldServletScopesSupportForSe implements Extension {</p>

<pre><code>/** {@inheritDoc} */
public void afterDeployment(@Observes final AfterDeploymentValidation event, 
                final BeanManager beanManager) {

    Map&lt;String, Object&gt; sessionMap = new HashMap&lt;String, Object&gt;();
    activateContext(beanManager, SessionScoped.class, sessionMap);

    Map&lt;String, Object&gt; requestMap = new HashMap&lt;String, Object&gt;();
    activateContext(beanManager, RequestScoped.class, requestMap);

    activateContext(beanManager, ConversationScoped.class, 
            new MutableBoundRequest(requestMap, sessionMap));
}

/**
 * Activates a context for a given manager.
 * @param beanManager in which the context is activated
 * @param cls the class that represents the scope
 * @param storage in which to put the scoped values
 * @param &lt;S&gt; the type of the storage
 */
private &lt;S&gt; void activateContext(final BeanManager beanManager,
            final Class&lt;? extends Annotation&gt; cls, final S storage) {
    BeanManagerImpl beanManagerImpl = (BeanManagerImpl) beanManager;
    @SuppressWarnings("unchecked")
    AbstractBoundContext&lt;S&gt; context = 
        (AbstractBoundContext&lt;S&gt;) beanManagerImpl.getContexts().get(cls).get(0);

    context.associate(storage);
    context.activate();
}
</code></pre>

<p>}
```</p>

<p>To register and activate a CDI extension, a file that contains the extension class name must be present and named <code>META-INF/services/javax.enterprise.inject.spi.Extension</code>.
<code>java META-INF/services/javax.enterprise.inject.spi.Extension
org.jboss.weld.manager.WeldServletScopesSupportForSe
</code></p>

<h2>Conclusion</h2>

<p>Testing the JEE6 outside of the container is easier and easier. Long gone are the days of the EJB 2.1 untestability.
Nevertheless, not everything is simple and we still have to do some tricks to get it working.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On JEE 6 Webapps Startup Time]]></title>
    <link href="http://hostettler.github.io/blog/2012/03/25/improve-jsf-applications-startup-time/"/>
    <updated>2012-03-25T23:20:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/03/25/improve-jsf-applications-startup-time</id>
    <content type="html"><![CDATA[<p>While working on Tomcat 7 embedded to automate my integration tests, I realized that my integration tests wasted much of the time in starting/stopping the server. Even if I do not start the integration tests as often as the unit tests, it becomes rapidly irritating. Furthermore, during development I tend to restart the server a couple of times per hour, especially at the beginning of the project. Sure hot deployment helps, but it is not always enough.</p>

<p>On my Mac Book Pro, a cold start took around 10s. Interestingly enough,  an empty Tomcat startups in less than a second. The problem comes from the fact that Tomcat 7 scans the classpath to find out annotations that declare Servlets using the <code>@WebServlet</code>. This, even if you do not use that feature. Don't get me wrong, not having to configure XML is cool but I am not ready to pay such a high price for it. Especially as the only servlet I use, is the JSF one.</p>

<h2>Where do we start from?</h2>

<p>For these tests, I use a JEE6 application with JSF, Weld and JPA (no EJBs) that runs under Tomcat. <br/>
This is a demo application called <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> that I use to teach JEE6.
A mentioned previously, a cold start (without tuning anything) requires around 10s on my Mac Book Pro Intel Core i7 with 8Gb RAM : <code>INFO: Server startup in 9992 ms</code></p>

<h2>Step 1: Avoid looking for <code>@WebSerlet</code> and co.</h2>

<p>By default, Tomcat 7 (along with the Servlet 3.0 specification) scans the classpath to look for classes that are annotated <code>@WebServlet</code>,<code>@WebServletContextListener</code>, <code>@ServletFilter</code>, or <code>@InitParamJSF</code>.  It is a nice feature as you do not have to specify the faces servlet anymore.
However, it comes at a price: depending of the classpath this can be very long.
To solve this issues, simple add the <code>metadata-complete="true"</code> to the <code>web-app</code> element of our <code>WEB-INF/web-xml</code> attribute to avoid scanning the classpath.</p>

<p>```xml web.xml's webapp element
&lt;web-app metadata-complete="true"</p>

<pre><code>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee"
xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
id="MyWebApp" version="3.0"&gt;
</code></pre>

<p>```</p>

<p>Obviously, as it is no more automatically discovered, we have  to manually add the faces servlet to the context:</p>

<p>```xml Add the faces servlet</p>

<pre><code>&lt;servlet&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/faces/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>

<p>```</p>

<p>Using these modifications in <code>web.xml</code>, the startup time came down to around 4.5 seconds:
<code>INFO: Server startup in 4404 ms</code></p>

<h2>Step 2: Avoid looking for <code>@ManagedBean</code> and co.</h2>

<p>Similarly, the is a similar feature in JSF 2.0. By default, the JSF implementation looks for classes annotated with
As I use Weld and its <code>@Named</code>, <code>@SessionScoped</code>, and so on, I can disable this feature in JSF.
<code>xml faces-config.xml annotated with metadata-complete="true"
&lt;faces-config xmlns="http://java.sun.com/xml/ns/javaee"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-facesconfig_2_0.xsd"
   version="2.0"  metadata-complete="true"&gt;
</code></p>

<p>Using this modification in <code>faces-config.xml</code>, the startup time came down to around 3.7 seconds:
<code>INFO: Server startup in 3730 ms</code></p>

<h2>Step 3: Limiting Weld's scanning</h2>

<p>Finally, I would like to keep Weld scanning to discover the <code>@Named</code>, <code>@Inject</code>, and other Weld annotations but I would like to limit it to my a subset of the classes of the jar. To that end simply add <code>weld:scan</code> directive and include a pattern with packages to scan.</p>

<p>```
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://java.sun.com/xml/ns/javaee"</p>

<pre><code>    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xmlns:weld="http://jboss.org/schema/weld/beans" 
    xsi:schemaLocation="
       http://java.sun.com/xml/ns/javaee http://jboss.org/schema/cdi/beans_1_0.xsd
       http://jboss.org/schema/weld/beans http://jboss.org/schema/weld/beans_1_1.xsd"&gt;
</code></pre>

<p>&lt;weld:scan></p>

<pre><code>&lt;weld:include pattern="ch.demo.*"/&gt;
</code></pre>

<p>&lt;/weld:scan>
```</p>

<p>Using this modification in <code>beans.xml</code>, the startup time came down to around 3.3 seconds:
<code>INFO: Server startup in 3312 ms</code></p>

<p>To conclude, using these minor modifications I divided the startup time by three. This is very useful during development and integration tests when the server is started and stopped many times.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing JPA 2.0 Entities in Java SE]]></title>
    <link href="http://hostettler.github.io/blog/2012/03/19/testing-jpa-in-java-se/"/>
    <updated>2012-03-19T13:40:00+01:00</updated>
    <id>http://hostettler.github.io/blog/2012/03/19/testing-jpa-in-java-se</id>
    <content type="html"><![CDATA[<p>Testing JPA components in Java SE has been greatly simplified since JEE6.
Nevertheless, it is still not as simple as testing other components.
Although there exist some frameworks such as <a href="http://www.jboss.org/arquillian">Arquillian</a> that solve that problematic,
it is sometimes to much of hammer to test a couple of entities and simple services.
Here is a post in which I digest some other posts and my own experience of how to test JPA components. The following example is part
of a Demo project I use to teach the JEE stack that is located on Google Code Hosting and <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a>
This project relies on <a href="http://maven.apache.org/">Maven 3</a> for build and dependency management. It does not use EJBs (at least for now) and thus it can be deployed in a Servlet engine.
Please note, that to me the kind of tests we are doing here are not unit tests (though we use JUnit ). Actually, as a database is required,
these  are integration tests.</p>

<p>Let us assume that we want to test that the following model has been properly annotated and can be persisted according to a given DB schema:
``` java An annotated entity that represent a student
// Get the entity manager for the tests.
@Entity
@Table(name = "STUDENTS")
public class Student implements Serializable {</p>

<pre><code>private static final long serialVersionUID = -6146935825517747043L;

@Id
@Column(name = "ID")
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long mId;

@Column(name = "LAST_NAME", length = 35)
private String mLastName;

@Column(name = "FIRST_NAME", nullable = false, length = 35)
private String mFirstName;

@Column(name = "BIRTH_DATE", nullable = false)
@Temporal(TemporalType.DATE)
private Date mBirthDate;
</code></pre>

<p>}
<code>
with the following persistence unit:
</code>
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;persistence version="1.0"</p>

<pre><code>xmlns="http://java.sun.com/xml/ns/persistence"&gt;
&lt;persistence-unit name="JEE6Demo-Persistence"
    transaction-type="RESOURCE_LOCAL"&gt;
    &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;
    &lt;class&gt;ch.demo.dom.Student&lt;/class&gt;
    &lt;properties&gt;
        &lt;property name="eclipselink.target-database" value="MYSQL" /&gt;
        &lt;property name="javax.persistence.jdbc.driver" value="com.mysql.jdbc.Driver" /&gt;
        &lt;property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/Students_DB" /&gt;
        &lt;property name="javax.persistence.jdbc.user" value="root" /&gt;
        &lt;property name="javax.persistence.jdbc.password" value="" /&gt;           
        &lt;property name="eclipselink.ddl-generation" value="none" /&gt;
        &lt;property name="eclipselink.logging.level" value="INFO" /&gt;
    &lt;/properties&gt;
&lt;/persistence-unit&gt;
</code></pre>

<p></persistence>
```</p>

<p>We use <a href="http://www.eclipse.org/eclipselink/">Eclipse-link</a> as it is the reference implementation for JPA 2.0
```xml Eclipse-Link dependencies</p>

<pre><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;EclipseLink Repo&lt;/id&gt;
        &lt;name&gt;EclipseLink Repository&lt;/name&gt;
        &lt;url&gt;http://download.eclipse.org/rt/eclipselink/maven.repo&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;
        &lt;artifactId&gt;eclipselink&lt;/artifactId&gt;
        &lt;version&gt;2.0.0&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;
        &lt;artifactId&gt;javax.persistence&lt;/artifactId&gt;
        &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>```</p>

<p>Since JEE 6, it is easy to start the JPA manager in a unit test. Let us look at the following listing. The first two lines initialize the persistence manager given a persistence unit. The name of the persistence unit must matched the declared persistence unit in <code>META-INF/persistence</code>. After what, the try block gets a transaction and starts it. The object student is persisted and the transaction is committed. If anything goes wrong, the transaction is roll-backed. Finally, the entity manager and the factory are closed.
``` java Start the JPA manager manually
// Get the entity manager for the tests.
EntityManagerFactory emf = Persistence.createEntityManagerFactory("JEE6Demo-Persistence");
EntityManager em = emf.createEntityManager();
try {
   //Get a new transaction
   EntityTransaction trx = em.getTransaction();</p>

<p>   //Start the transaction
   trx.begin();
   //Persist the object in the DB
   em.persist(student);
   //Commit and end the transaction
   trx.commit();
} catch (RuntimeException e) {
   if (trx != null &amp;&amp; trx.isActive()) {</p>

<pre><code>  trx.rollback();
</code></pre>

<p>   }
   throw e;
} finally {
   //Close the manager
   em.close();
   emf.close();
}
```</p>

<p>There are several open issues problems with this code:</p>

<ol>
<li>We do want to use a local in memory database. Indeed, we do not want to mess up with the information stored on the Mysql database. Finally, we need the test to be as autonomous as possible. That is that it does not depend on an external server (e.g. app server, database server).</li>
<li>JUnit does not guarantee the order in which the tests are ran.
Therefore, we must initialize the manager before each and every test of the fixture. Furthermore we must close it after the test to
avoid session leaks.</li>
<li>During tests, we must make sure that the database is in an acceptable state before running each unit.</li>
</ol>


<p>To limit the dependencies to other components and to keep the setting simple, we will use <a href="http://db.apache.org/derby/">Derby</a> as a pure in
memory database. That is no file produced during the database execution and thus no cleaning afterwards. Please note that is only used for testing purposes.</p>

<p>```xml Derby in memory database dependencies
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.derby&lt;/groupId&gt;
&lt;artifactId&gt;derby&lt;/artifactId&gt;
&lt;version&gt;10.8.2.2&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency> <br/>
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.derby&lt;/groupId&gt;
&lt;artifactId&gt;derbyclient&lt;/artifactId&gt;
&lt;version&gt;10.8.2.2&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<p>The following <code>persistence.xml</code> file sets  <code>DERBY</code> as a target database language. Using Derby, selecting the embedded
drivers in conjunction <code>org.apache.derby.jdbc.EmbeddedDriver</code> with a <code>jdbc:derby:memory</code> URL runs a database in memory without
persisting anything to disk. This combination is important as it otherwise will store file on the disk.
The following will be used by <code>Maven</code> during the test because it overrides the one in `/main/resources/META-INF/``. This is an elegant way to use a different database setting for the unit tests.
``` xml Persistence descriptor /test/resources/META-INF/persistence.xml
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;persistence version="1.0"</p>

<pre><code>xmlns="http://java.sun.com/xml/ns/persistence"&gt;
&lt;persistence-unit name="JEE6Demo-Persistence"
    transaction-type="RESOURCE_LOCAL"&gt;
    &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;
    &lt;class&gt;ch.demo.dom.Student&lt;/class&gt;
    &lt;properties&gt;
        &lt;property name="eclipselink.logging.level" value="FINE" /&gt;
        &lt;property name="eclipselink.target-database" value="DERBY" /&gt;
        &lt;property name="javax.persistence.jdbc.driver" value="org.apache.derby.jdbc.EmbeddedDriver" /&gt;
        &lt;property name="javax.persistence.jdbc.url" value="jdbc:derby:memory:StudentsDB;create=true" /&gt;
        &lt;property name="javax.persistence.jdbc.user" value="" /&gt;
        &lt;property name="javax.persistence.jdbc.password" value="" /&gt;
        &lt;property name="eclipselink.logging.level" value="INFO" /&gt;
    &lt;/properties&gt;        
&lt;/persistence-unit&gt;
</code></pre>

<p></persistence>
```</p>

<p>To solve the second issue, we must guarantee that each test fixture gets a fresh entity manager. JUnit 4+ executes whatever
public static method annotated with <code>@BeforeClass</code> before firing up the class constructor. Similarly, methods annotated with <code>@AfterClass</code>
are executed after all the tests and is therefore a good place for cleanup.
``` java Start the JPA manager before for each test fixture</p>

<p>/<strong> The factory that produces entity manager. */
private static EntityManagerFactory mEmf;
/</strong> The entity manager that persists and queries the DB. */
private static EntityManager mEntityManager;</p>

<p>@BeforeClass
public static void initTestFixture() throws Exception {</p>

<pre><code>// Get the entity manager for the tests.
mEmf = Persistence.createEntityManagerFactory(mPersistenceUnit);
mEntityManager = mEmf.createEntityManager();
...
</code></pre>

<p>}</p>

<p> /<em>*
 * Cleans up the session.
 </em>/
@AfterClass
public static void closeTestFixture() {</p>

<pre><code>mEntityManager.close();
mEmf.close();
</code></pre>

<p>}
```</p>

<p>The problem with the pure in-memory approach is that schema has to recreated for each run. One solution would be to rely on the <code>Eclipse-link</code> DDL creation. I do not really like this solution as it usually not accepted by the customers that tend to want to have control
of their schema. Thus, to have a test setting that is as close as possible to the production setting we need something to install the schema
by running a SQL file. There are many solutions out there:</p>

<ul>
<li>Manually parsing the SQL file. I do not like this solution as it becomes rapidly intractable when the file contains comments and transactions.</li>
<li>Using tools such as <a href="http://www.liquibase.org/">Liquibase</a>. Nice solution but to me it was to much of a hammer to that specific case.</li>
<li>Using an API that does it for me.</li>
</ul>


<p>I propose the last approach by using <code>Derby Tools</code> and in particular the API of <code>ij</code>.
```xml DBUnit dependency
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.derby&lt;/groupId&gt;
&lt;artifactId&gt;derbytools&lt;/artifactId&gt;
&lt;version&gt;10.8.2.2&lt;/version&gt;
</code></pre>

<p></dependency>
```</p>

<p>This allows to use <code>ij</code> directly in the test to parse the DDL file. This is shown in the following listing.
First, it gets the underlying JDBC connection and then it run the file located in <code>test/resources/sql/</code>.</p>

<p>```java
@BeforeClass
public static void initTestFixture() throws Exception {</p>

<pre><code>// Get the entity manager for the tests.
mEmf = Persistence.createEntityManagerFactory(mPersistenceUnit);
mEntityManager = mEmf.createEntityManager();

Connection connection = ((EntityManagerImpl) (mEntityManager
        .getDelegate())).getServerSession().getAccessor()
        .getConnection();

ij.runScript(connection,
        AbstractDBTest.class.getResourceAsStream("sql/studentSchema.ddl"),
        "UTF-8", System.out, "UTF-8");
</code></pre>

<p>}
```</p>

<p>The third item asks for a way to properly initialize the data prior to the test. Remember that your tests should not rely on the success of
previous ones. To that end, we cleanup the data prior any test execution. A rather easy way to do that is to use
<a href="http://www.dbunit.org/">DBUnit</a>.</p>

<p>```xml DBUnit dependency</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.dbunit&lt;/groupId&gt;
    &lt;artifactId&gt;dbunit&lt;/artifactId&gt;
    &lt;version&gt;2.4.8&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p><code>
It loads a file named `/test/resources/students-datasets.xml`` from the test resources.
</code>java Initialize the test dataset</p>

<pre><code>@BeforeClass
public static void initTestFixture() throws Exception {
// Get the entity manager for the tests.
mEmf = Persistence.createEntityManagerFactory(mPersistenceUnit);
mEntityManager = mEmf.createEntityManager();

Connection connection = ((EntityManagerImpl) (mEntityManager
        .getDelegate())).getServerSession().getAccessor()
        .getConnection();

ij.runScript(connection,
        AbstractDBTest.class.getResourceAsStream("sql/studentSchema.ddl"),
        "UTF-8", System.out, "UTF-8");

    mDBUnitConnection = new DatabaseConnection(connection);
    //Loads the data set from a file named students-datasets.xml
    mDataset = new FlatXmlDataSetBuilder().build(Thread.currentThread()
            .getContextClassLoader()
            .getResourceAsStream("students-datasets.xml"));

    ...
}
</code></pre>

<p>```</p>

<p>After what, clean test data are inserted for each and every test of the fixture:</p>

<p>```java init of the test</p>

<pre><code>@Before
public void initTest() throws Exception {
    //Clean the data from previous test and insert new data test.
    DatabaseOperation.CLEAN_INSERT.execute(mDBUnitConnection, mDataset);
}
</code></pre>

<p>```</p>

<p>In this post, I've showed how to test the persistence of an JPA 2.0 entity using JUnit 4. The test setting runs in memory without external server  and enforces a clean database state prior running the tests.</p>

<p>To support my teaching activities on Java EE 6, I've setup a project on Google Code Hosting that contains all the presented sources and much more. Please give me feedbacks on how to improve that demo project and in particular its
testability.</p>
]]></content>
  </entry>
  
</feed>
