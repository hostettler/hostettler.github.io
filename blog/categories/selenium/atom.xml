<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Selenium | Steve Hostettler]]></title>
  <link href="http://hostettler.github.io/blog/categories/selenium/atom.xml" rel="self"/>
  <link href="http://hostettler.github.io/"/>
  <updated>2014-05-31T23:06:21+02:00</updated>
  <id>http://hostettler.github.io/</id>
  <author>
    <name><![CDATA[Steve Hostettler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Selenium for web integration testing]]></title>
    <link href="http://hostettler.github.io/blog/2012/04/16/using-selenium-for-web-integration-testing/"/>
    <updated>2012-04-16T18:57:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/04/16/using-selenium-for-web-integration-testing</id>
    <content type="html"><![CDATA[<p>Following up on my previous posts (<a href="/blog/2012/04/09/embedded-jee-web-application-integration-testing-using-tomcat-7/">here</a>
and <a href="/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap/">here</a> about integration testing
of JEE web applications, I will present how to write smoke tests using Selenium. The idea is to
detect whether important regressions have been introduced. This is especially useful to detect
configuration and navigation problems. I've split the test in three parts:</p>

<ol>
<li>starting and stopping the container. Embedded Tomcat 7 in our case. This is described
<a href="/blog/2012/04/09/embedded-jee-web-application-integration-testing-using-tomcat-7">here</a>;</li>
<li>building the WAR file to test. To that end, you can look at this
<a href="/blog/2012/04/05/programmatically-build-web-archives-using-shrinkwrap">post</a> that describes how to
build such a test archive using Shrinkwrap;</li>
<li>finally, we must build the test case. This is the goal of this post.</li>
</ol>


<p>Testing a use case requires to be able to:</p>

<ol>
<li>get a page at a given URL;</li>
<li>input test data into the web elements;</li>
<li>assert whether the server answers as expected.</li>
</ol>


<p>Selenium provides an easy API to fetch URLs
As these are smoke tests, using the <code>HtmlUnitDriver</code> instead of a specific browser is sufficient.
We do not want to detect minor display problems but rather important functional problems.</p>

<p>Selenium has many different drivers for many different browser. The problem is that it opens the
browser in a new window. I prefer to have the continuous integration running headless.</p>

<p>The following dependencies are required to run the tests.</p>

<p>```xml Maven dependencies
<dependency></p>

<pre><code>&lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;
&lt;artifactId&gt;selenium-java&lt;/artifactId&gt;
&lt;version&gt;2.20.0&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
<dependency></p>

<pre><code>&lt;groupId&gt;net.sourceforge.htmlunit&lt;/groupId&gt;
&lt;artifactId&gt;htmlunit&lt;/artifactId&gt;
&lt;version&gt;2.9&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<p>First, let's build a new headless driver. This object simulates the browser. It manages the HTTP part as
well as parsing the HTML and the javascript code that is returned.</p>

<p><code>java
WebDriver driver = new HtmlUnitDriver();
</code></p>

<p>The next step is to ask the driver to load the home page that we want to test. For
convenience, in my previous posts I defined a method that returns the current Tomcat port and the
application context.</p>

<p><code>java
driver.get("http://localhost:" + getTomcatPort() + "/" + getApplicationId());
</code></p>

<p>Let's assume that the home page redirects to a login page that has two text boxes (respectively
called <code>username</code> and password). The following snippet uses XPATH expressions to locate web elements.
First, it locates a HTML element of type <code>input</code> that has an
attribute  <code>id</code> set to <code>username</code>. If this web element is not present, the driver will raise an exception.
This allows to easily detect whether a widget has been accidentally removed.</p>

<p><code>java
WebElement username = driver.findElement(By.xpath("//input[contains(@id,'username')]"));
</code></p>

<p>Now we can interact with the previous element. For instance, to simulate a user that types in its username (<code>admin</code>).
<code>java
username.sendKeys("admin");
</code></p>

<p>After that, Let's do the same for the web element called <code>password</code>.
<code>java
WebElement password = driver.findElement(By.xpath("//input[contains(@id,'password')]"));
password.sendKeys("admin");
</code></p>

<p>Finally, we locate a button called <code>login</code>and we simulate a click on it.</p>

<p><code>java
WebElement login = driver.findElement(By.xpath("//button[contains(@id,'login')]"));
login.click();
</code></p>

<p>On successful login, our example redirects to a page that contains a list of students.
The following assertion checks that the string <code>Student list</code> exists somewhere is the returned
HTML source code.</p>

<p><code>java
Assert.assertTrue(driver.getPageSource().contains("Student list"));
</code></p>

<p>With this approach, it is also very easy to do trivial security testing. For instance, let's check that
the application redirects (or forwards) the user to the login page upon unsuccessful login.
<code>java
WebElement username = driver.findElement(By.xpath("//input[contains(@id,'username')]"));
username.sendKeys("foo");
WebElement password = driver.findElement(By.xpath("//input[contains(@id,'password')]"));
password.sendKeys("foo");
WebElement login = driver.findElement(By.xpath("//button[contains(@id,'login')]"));
login.click();
Assert.assertTrue(driver.getPageSource().contains("username"));
Assert.assertTrue(driver.getPageSource().contains("password"));
Assert.assertTrue(driver.getPageSource().contains("login"));
</code></p>

<h2>Conclusion</h2>

<p>In this post, we have seen how to write smoke integration tests with Selenium. This is especially
useful to detect whether an important functionality has been hindered. For instance, a change in the
navigation or a unexpected change of the status (availability, visibility) of one the buttons or web elements.
I recommend implementing the three or four major scenarios with this technique. This is usually enough to
detect major problems. The examples used in this blog are to be found in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project on <a href="http://code.google.com">Google code hosting</a>.</p>
]]></content>
  </entry>
  
</feed>
