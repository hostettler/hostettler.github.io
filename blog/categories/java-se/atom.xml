<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java SE | Steve Hostettler]]></title>
  <link href="http://hostettler.github.io/blog/categories/java-se/atom.xml" rel="self"/>
  <link href="http://hostettler.github.io/"/>
  <updated>2015-01-16T18:22:51+01:00</updated>
  <id>http://hostettler.github.io/</id>
  <author>
    <name><![CDATA[Steve Hostettler]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Object-XML Mapping with JAXB & MOXy]]></title>
    <link href="http://hostettler.github.io/blog/2012/05/24/moxy/"/>
    <updated>2012-05-24T19:17:00+02:00</updated>
    <id>http://hostettler.github.io/blog/2012/05/24/moxy</id>
    <content type="html"><![CDATA[<p>Object-Relational mapping is around for a while and its last incarnation, JPA 2.0, is easy to use
yet powerful and adapted to most of the real-life situations. A problem that is similar to
Object-Relational mapping (ORM) is Object-XML mapping (OXM). More precisely, it aims at mapping XML
schemas to JAVA classes. JAXB (JSR 222) specifies how to maps classes to xml schemas.
In this post, I demonstrate the ease of use of this approach using <a href="http://www.eclipse.org/eclipselink/moxy.php">MOXy</a>. MOXy is the Eclipse implementation of JAXB and I found it really easy to use.</p>

<p>As always let us first look at the Maven dependencies:
```xml Maven dependencies for using MOXy
<repositories></p>

<pre><code>    &lt;repository&gt;
        &lt;id&gt;EclipseLink Repo&lt;/id&gt;
        &lt;name&gt;EclipseLink Repository&lt;/name&gt;
        &lt;url&gt;http://download.eclipse.org/rt/eclipselink/maven.repo&lt;/url&gt;
    &lt;/repository&gt;
</code></pre>

<p></repositories></p>

<p><dependencies></p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;
    &lt;artifactId&gt;eclipselink&lt;/artifactId&gt;
    &lt;version&gt;2.3.2&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
...
</code></pre>

<p></dependencies>  <br/>
```</p>

<p>Eclipse-link provides an implementation for JAXB. The rest is in the JEE 6 SDK.</p>

<p>In this post I only consider the case in which we have control over the schema.
In this case, it is sufficient to annotate the fields and the classes you want to marshall to XML.
Let us use the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project that can be found on Google
Code. The following snippet shows a simple model that represents a student.</p>

<p>As you can see there are few annotations. The first one <code>@XmlRootElement</code> simply declares what the  root element is. The second annotation specifies the mapping policy. We will come back on that later. The fields are either not annotated or annotated with @Transient. In the first case, they
are marshaled if not null and in the second they are simply ignored. The only tricky part is that transient fields (in the Java sense) are ignored. For instance, this is the case of the <code>gender</code> property.</p>

<p>```java A simple mapping from object to XML
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class Student implements Serializable {</p>

<pre><code>private Long id;

private String lastName;

private String firstName;

private Date birthDate;

@XmlTransient
private PhoneNumber phoneNumber;

private transient Gender gender;

@XmlTransient
private Address address;

@XmlTransient
private List&lt;Grade&gt; grades;

...

@XmlTransient
private Badge badge;
...
</code></pre>

<p>}
```</p>

<p>Let us now test the mapping. The code below, creates a new <code>Student</code> and fills the associated
fields. The second part of the snippet marshals the object into XML and streams it to <code>System.out</code>.</p>

<p>```java Creation of student and its marshaling to XML</p>

<pre><code>Student student = new Student("Lion Hearth", "Richard", new Date());
Address address = new Address();
address.setCity("Carouge");
address.setNumber("7");
address.setPostalCode("1227");
address.setStreet("Drize");
student.setAddress(address);
Badge b = new Badge();
b.setSecurityLevel(30L);
b.setStudent(student);
student.setBadge(b);
student.setPhoneNumber(new PhoneNumber(0, 0, 0));
for (Discipline d : Discipline.values()) {
    Grade g = new Grade(d, 10);
    student.getGrades().add(g);
}

JAXBContext jaxbContext = JAXBContext.newInstance(Student.class);       
Marshaller marshaller = jaxbContext.createMarshaller();
marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
marshaller.marshal(student, System.out);
</code></pre>

<p>```</p>

<p>Finally, the result looks like the XML below. As you can see, it is pretty easy and straight-forward
to produce XML from a Class description. Most of the fields that have been populated are not
marshaled to XML. This is due to the <code>@XMLTransient</code> annotation that tells JAXB not to consider
them for output.</p>

<p>```xml Marshaled version of the previous Student object.
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student></p>

<pre><code>&lt;lastName&gt;Lion Hearth&lt;/lastName&gt;
&lt;firstName&gt;Richard&lt;/firstName&gt;
&lt;birthDate&gt;2012-06-04T11:12:34.751+02:00&lt;/birthDate&gt;
</code></pre>

<p></student>
```</p>

<h3>Mapping Overview</h3>

<p>The previous example was as simple as possible. Obviously, sometimes it is important to be able to
tweak the mapping. Let us look at some simple mapping options.</p>

<h4>Element naming</h4>

<p>The default mapping rule is to use the field name as XML element name. This policy can be overridden
by the <code>@XmlElement(name = ...)</code> annotation. Applying the annotation <code>@XmlElement(name="last_name")</code> on the <code>lastName</code> field of the previous example would result in:
```xml Example of named element
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student></p>

<pre><code>&lt;last_name&gt;Lion Hearth&lt;/last_name&gt;
&lt;firstName&gt;Richard&lt;/firstName&gt;
&lt;birthDate&gt;2012-06-04T11:12:34.751+02:00&lt;/birthDate&gt;
</code></pre>

<p></student>
```</p>

<h4>Attributes vs elements</h4>

<p>By default fields are marshaled as XML elements. It is possible to ask JAXB to transform them to
XML attributes by using <code>@XmlAttribute</code> annotation. Putting <code>@XmlAttribute</code> on the <code>lastName</code>
field of the previous example would produce the following XML:
```xml Example of using an attribute instead of an element
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student lastName="Lion Hearth"></p>

<pre><code>&lt;firstName&gt;Richard&lt;/firstName&gt;
&lt;birthDate&gt;2012-06-04T11:12:34.751+02:00&lt;/birthDate&gt;
</code></pre>

<p></student>
```
Please note that as for an element, the attribute name can be customized.</p>

<h4>Mapping strategy</h4>

<p>As mentioned before, the default mapping strategy is declared by using the <code>@XmlAccessorType(XmlAccessType.*)</code> annotation.</p>

<p>There exists four mapping policies. For more details, look at the <a href="http://docs.oracle.com/javaee/6/api/javax/xml/bind/annotation/XmlAccessType.html">Javadoc</a> for <code>XmlAccessorType</code>. Here is an excerpt
from the Java doc.</p>

<ol>
<li><code>FIELD</code>: Every non static, non transient field in a JAXB-bound class will be automatically bound to XML, unless annotated by XmlTransient.</li>
<li><code>NONE</code>: None of the fields or properties is bound to XML unless they are specifically annotated with some of the JAXB annotations.</li>
<li><code>PROPERTY</code>: Every getter/setter pair in a JAXB-bound class will be automatically bound to XML, unless annotated by XmlTransient.</li>
<li><code>PUBLIC_MEMBER</code>: Every public getter/setter pair and every public field will be automatically bound to XML, unless annotated by XmlTransient.</li>
</ol>


<h4>Name spaces</h4>

<p>An important aspect of XML is its modularity. In particular, namespaces bring a nice way to organize
the XML and the schemas. Namespaces can be specified at different levels. For more details look at the <a href="http://wiki.eclipse.org/EclipseLink/UserGuide/MOXy/Type_Level/Setting_Up_Namespace_Information">MOXy documentation</a>. For now, it is sufficient to known that the <code>@XmlType</code>, <code>@XmlElement</code>, and <code>@XmlAttribute</code> annotations support a namespace attribute.</p>

<h3>One to one mapping</h3>

<p>Now that we have mapped simple field, let us look at more complex mappings. First, a 1-1 mapping.
The following example maps an address.</p>

<p>```java Add a one to one mapping
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class Student implements Serializable {</p>

<pre><code>...

private Address address;
</code></pre>

<p>}
<code>
To that end, it is sufficient to add the following annotations to the Address type.
</code>
@XmlRootElement(name = "address")
@XmlAccessorType(XmlAccessType.FIELD)
public class Address implements Serializable {</p>

<pre><code>...
/** house number. */
private String number;

/** the name of the street. */
private String street;

/** the city name. */
private String city;

/** the postal code. */
private String postalCode;
...
</code></pre>

<p>}
```</p>

<p>And the rest is handled by JAXB to produce the following result.</p>

<p>```xml
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student></p>

<pre><code>...
&lt;address&gt;
    &lt;number&gt;7&lt;/number&gt;
    &lt;street&gt;Drize&lt;/street&gt;
    &lt;city&gt;Carouge&lt;/city&gt;
    &lt;postalCode&gt;1227&lt;/postalCode&gt;
&lt;/address&gt;
</code></pre>

<p></student>
```</p>

<h4>Bi-directional one to one</h4>

<p>The next example is more tricky. The problem with bi-directional mapping is that they produce
graphs. Of course, since XML are trees, we must avoid cycles. The solution is to annotate the reverse mapping (<code>Student student</code> in this case) with <code>@XMLTransient</code> causing the property to be ignored by JAXB.</p>

<p>```java Add a one to one bidirectional mapping
@XmlRootElement(name = "student")
@XmlAccessorType(XmlAccessType.FIELD)
public class Student implements Serializable {</p>

<pre><code>...

private Badge badge;
</code></pre>

<p>}
```</p>

<p>The following type describes the <code>Badge</code> that has a reverse mapping to <code>Student</code>.
<code>`java Mapping of the type</code>Badge``
@XmlRootElement(name = "badge")
@XmlAccessorType(XmlAccessType.FIELD)
public class Badge implements Serializable {</p>

<pre><code>/** The unique id. */
private Long id;

/** The student's security level. */
@XmlAttribute
private Long securityLevel;

/** The student that owns this badge. */
@XmlTransient
private Student student;
</code></pre>

<p>```
And finally, here is the result.</p>

<p>```xml Result of the bi-directional mapping
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student></p>

<pre><code>...
&lt;badge securityLevel="30"/&gt;
</code></pre>

<p></student>
```</p>

<h3>One to many mapping</h3>

<p>One to many mappings are handled automatically. There is nothing special to do. In our example,
removing the <code>@XmlTransient</code> annotation on the <code>grades</code> property will generate the following output:</p>

<p>```xml One to many example
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student></p>

<pre><code>&lt;last_name&gt;Lion Hearth&lt;/last_name&gt;
&lt;firstName&gt;Richard&lt;/firstName&gt;
&lt;birthDate&gt;2012-06-05T10:57:36.699+02:00&lt;/birthDate&gt;
&lt;phoneNumber&gt;+00-0000-0000&lt;/phoneNumber&gt;
&lt;address&gt;
    &lt;number&gt;7&lt;number&gt;
    &lt;street&gt;Drize&lt;/street&gt;
    &lt;city&gt;Carouge&lt;/city&gt;
    &lt;postalCode&gt;1227&lt;/postalCode&gt;
&lt;/address&gt;
&lt;grades&gt;
    &lt;discipline&gt;MATHEMATICS&lt;/discipline&gt;
    &lt;grade&gt;10&lt;/grade&gt;
&lt;/grades&gt;
&lt;grades&gt;
    &lt;discipline&gt;BIOLOGY&lt;/discipline&gt;
    &lt;grade&gt;10&lt;/grade&gt;
&lt;/grades&gt;
</code></pre>

<p> ...</p>

<pre><code>&lt;badge securityLevel="30"/&gt;
</code></pre>

<p></student>
```</p>

<h2>Custom mapping</h2>

<p>Sometimes, it is difficult to map a given type to a given XML structure. This is the case of the <code>PhoneNumber</code> type in our example. To that end, it is possible to define a <code>XMLJavaTypeAdatper</code>
that will convert XML to object and objects to XML manually. The adapter is not very difficult to implement. It is composed of two methods that respectively unmarshal from XML and marshal to XML.</p>

<p>```java
public class PhoneNumberAdapter extends XmlAdapter&lt;String, PhoneNumber> {</p>

<pre><code>@Override
public PhoneNumber unmarshal(final String value) throws Exception {
    return PhoneNumber.getAsObject((String) value);
}

@Override
public String marshal(final PhoneNumber value) throws Exception {
    return PhoneNumber.getAsString((PhoneNumber) value);
}
</code></pre>

<p>}
<code>
Then, it is required to annotated the property with this adapter:
</code>java Using a custom XML-Object Adapter</p>

<pre><code>...
@XmlJavaTypeAdapter(PhoneNumberAdapter.class)
private PhoneNumber mPhoneNumber;
...
</code></pre>

<p>```</p>

<p>This will produce the following result:
```xml
&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student></p>

<pre><code>&lt;last_name&gt;Lion Hearth&lt;/last_name&gt;
&lt;firstName&gt;Richard&lt;/firstName&gt;
&lt;birthDate&gt;2012-06-05T10:57:36.699+02:00&lt;/birthDate&gt;
&lt;phoneNumber&gt;+00-0000-0000&lt;/phoneNumber&gt;
...
</code></pre>

<p></student>  <br/>
```</p>

<h2>What about XML schemas</h2>

<p>As mentioned previously, we assumed that you have total control over the schema. Nevertheless, it can
be useful to be able to produce this schema. This is done by the following snippet.</p>

<p>```java Output the underlying schema
SchemaOutputResolver sor = new SchemaOutputResolver() {</p>

<pre><code>@Override
public Result createOutput(final String namespaceUri,
        final String suggestedFileName) throws IOException {
    Result result = new StreamResult(System.out);
    result.setSystemId("System.out");
    return result;
}
</code></pre>

<p>};
jaxbContext.generateSchema(sor);
```</p>

<h2>Write XML</h2>

<p>Writing XML is fairly easy, just populate the objects that you want to marshal and then
use the following code:
<code>java How to marshal a given object
JAXBContext jaxbContext = JAXBContext.newInstance(Student.class);       
Marshaller marshaller = jaxbContext.createMarshaller();
marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
marshaller.marshal(student, System.out);
</code></p>

<h2>Read XML</h2>

<p>The reverse operation is as easy and straightforward (provided that use the same schema):
<code>java How to unmarshal a given XML file to objects
InputStream stream = StudentOXTest.class.getResourceAsStream("/student.xml");
JAXBContext jaxbContext = JAXBContext.newInstance(Student.class);
Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
Student student = (Student) unmarshaller.unmarshal(stream);
</code></p>

<h2>Conclusion</h2>

<p>We have seen how to use MOXy to map objects to XML. Using JAXB annotations, it is very easy to read and write XML. The examples used in this blog are to be found in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project on <a href="http://code.google.com">Google code hosting</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[One to One relations in JPA 2.0]]></title>
    <link href="http://hostettler.github.io/blog/2012/03/22/one-to-one-relations-in-jpa-2-dot-0/"/>
    <updated>2012-03-22T10:41:00+01:00</updated>
    <id>http://hostettler.github.io/blog/2012/03/22/one-to-one-relations-in-jpa-2-dot-0</id>
    <content type="html"><![CDATA[<p>Recently I came across the need to map a one 2 one relationship from the object model to the database using JPA 2.0.
The case was pretty simple as the database was nicely organized but it raised the question: what if? What if I have to deal to a legacy system or a database administrator that has to follow strict company rules. Other reasons such as security or performances may interfere with simple designs. Hence, I had a look to the diverse ways to map a one 2 one relationship. I probably forgot several cases so please do not hesitate to discuss them in the comments.</p>

<p>A one to one relationship consider that the objects involved in the relation are highly dependent. In Object Orientation, this corresponds to the an aggregation or a composition. In a relational model, the data can be either:</p>

<ol>
<li>in the same table,</li>
<li>split over two (or more) tables (one per object) and linked by a foreign key, or</li>
<li>split over two (or more) tables and linked by a join table.</li>
</ol>


<p>The rest of the articles these describes different situations. Please note that for the sake of the explanation, I explicitly map all the fields even if most of the time the default mapping policy would work.</p>

<h2>Data in the same class: Embedded class</h2>

<p>This is especially useful for legacy code where the database design is a bit to flat for your taste.
The following figure presents the concept of an embedded class. The class <code>Address</code> is embedded in the class <code>Student</code>.
The idea is that <code>Address</code> is an entity per se, it exists only in the context of the class <code>Student</code>.</p>

<p><span class='caption-wrapper center'><img class='caption' src='/figures/one2oneVariante1.png' width='' height='' alt='One 2 One relations as an embedded class' title='One 2 One relations as an embedded class'><span class='caption-text'>One 2 One relations as an embedded class</span></span></p>

<p>To declare a embedded class, the class itself must be annotated with <code>@Embeddable</code> and its reference must be annotated with
<code>@Embedded</code>.</p>

<p>```java A embeddable class
@Embeddable
public class Address implements Serializable {</p>

<pre><code>...
@Column(name = "NUMBER")
private String number;

@Column(name = "STREET")
private String street;
...
</code></pre>

<p>}
```</p>

<p><code>@Embedded</code> and <code>@Basic</code> cannot be used together. Therefore, if required, lazy fetching must be declared field by field in the embedded class. Remember that outside of a JEE container,  the actual behavior of lazy loading on <code>@Basic</code> and <code>@OneToOne</code> depend on the actual implementation. Eclipse link, for instance, does not perform lazy loading by default on <code>@Basic</code>, <code>@OneToOne</code>, and <code>@ManyToOne</code> mappings. For more detail, please refer to the <a href="http://wiki.eclipse.org/Using_EclipseLink_JPA_Extensions_%28ELUG%29#What_You_May_Need_to_Know_About_EclipseLink_JPA_Lazy_Loading">Eclipse-link specification</a>.</p>

<p>```java The class Address is embedded into a Student
@Entity
@Table(name = "STUDENTS")
public class Student implements Serializable {</p>

<pre><code>...

@Id
@Column(name = "ID")
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long mId;

...

@Embedded
private Address mAddress;

...
</code></pre>

<p>}
```</p>

<p>The following SQL statement shows the code generated by the previous mapping.</p>

<p>```sql SQL code generated according to the previous mapping
SELECT  ID, FIRST_NAME, PHONE_NUMBER, BIRTH_DATE, LAST_NAME, NUMBER,</p>

<pre><code>    CITY, STREET, POSTAL_CODE 
</code></pre>

<p>  FROM  STUDENTS
```</p>

<h2>Data in different classes: Secondary Tables</h2>

<p>In the second scenario, the OO model is composed on only one class but the relational model is split over several tables.</p>

<h3>The foreign key is in the secondary table</h3>

<p><span class='caption-wrapper center'><img class='caption' src='/figures/one2oneVariante2.png' width='' height='' alt='Data is in different tables with the foreign key in the secondary table' title='Data is in different tables with the foreign key in the secondary table'><span class='caption-text'>Data is in different tables with the foreign key in the secondary table</span></span></p>

<p>In this case, the concepts of secondary tables is very useful. A secondary table is basically a table that hosts
important data that are one to one related to the data of the primary table.
Unlike the first case, a join is required and thus a key mapping is required.
In the following mapping, the secondary table <code>PICTURES</code> is mapped using its <code>STUDENT_ID</code> field to the <code>ID</code> field
of the main table.</p>

<p>```java Mapping of the Student entity
@SecondaryTable(name = "PICTURES",</p>

<pre><code>pkJoinColumns = @PrimaryKeyJoinColumn(name = "STUDENT_ID", 
    referencedColumnName = "ID"))
</code></pre>

<p>public class Student implements Serializable {</p>

<pre><code>...
@Id
@Column(name = "ID")
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long mId;

/** A picture of the student. */
@Lob
@Basic(optional = true, fetch = FetchType.EAGER)
@Column(table = "PICTURES", name = "PICTURE", nullable = true)
private byte[] mPicture;
...
</code></pre>

<p><code>`
The following SQL statement shows the code generated by the previous mapping.
It joins the two tables according to the</code>@PrimaryKeyJoinColumn`` annotation.</p>

<p>```sql SQL code generated by the previous mapping
SELECT  t0.ID, t1.STUDENT_ID, t1.PICTURE, t0.FIRST_NAME, t0.PHONE_NUMBER, t0.BIRTH_DATE,</p>

<pre><code>    t0.LAST_NAME, t0.NUMBER, t0.CITY, t0.STREET, t0.POSTAL_CODE 
</code></pre>

<p>  FROM  STUDENTS t0, PICTURES t1
 WHERE  (t1.STUDENT_ID = t0.ID)</p>

<p>```</p>

<h3>The foreign key is in the host table</h3>

<p>Similarly to the previous case, the data is split over several tables. The difference lies in the foreign key position.
Here the foreign key is hosted in the primary table.
<span class='caption-wrapper center'><img class='caption' src='/figures/one2oneVariante3.png' width='' height='' alt='Data is in different tables with the foreign key in the primary/host table' title='Data is in different tables with the foreign key in the primary/host table'><span class='caption-text'>Data is in different tables with the foreign key in the primary/host table</span></span></p>

<p>From a mapping point of view, it is very similar to the previous case. Indeed only the key column names have to be changed
to reflect the organization.</p>

<p>```java Mapping of the Student entity
@SecondaryTable(name = "PICTURES",</p>

<pre><code>pkJoinColumns = @PrimaryKeyJoinColumn(name = "PICTURE_ID", 
    referencedColumnName = "PICTURE_ID"))
</code></pre>

<p>public class Student implements Serializable {
```</p>

<p>The following SQL statement shows the code generated by the previous mapping.
Again, the data are joined according to the content of the <code>@PrimaryKeyJoinColumn</code> annotation.</p>

<p>```sql SQL code generated by the previous mapping
SELECT  t0.ID, t0.PICTURE_ID, t1.PICTURE_ID, t1.PICTURE, t0.FIRST_NAME, t0.PHONE_NUMBER, t0.BIRTH_DATE,</p>

<pre><code>    t0.LAST_NAME,t0.NUMBER, t0.CITY, t0.STREET, t0.POSTAL_CODE 
</code></pre>

<p>  FROM  STUDENTS t0, PICTURES t1
 WHERE  (t1.PICTURE_ID = t0.PICTURE_ID)
```</p>

<h2>First and second class JPA citizens</h2>

<p>In the previous examples, the table <code>PICTURES</code> does not have a business existence in itself. It is a secondary table because its data only have meaning in relation to the data of the primary table. Sometimes, we may want to treat the second objects as first class JPA citizens and thus we must put the <code>@Entity</code> annotation on it. In this case, we have to use the <code>@OneToOne</code> annotation for the mapping. Unlike the previous mappings, <code>@OneToOne</code> enable bidirectional mapping.</p>

<p>In the last example, the tables <code>STUDENTS</code> and  <code>BADGES</code> have a one to one relationship modeled with a foreign in the <code>BADGES</code> table to the <code>STUDENTS</code> table. In this case, the owning side is the <code>Badge</code> entity has it contains the foreign key.</p>

<p>As mentioned before, the class <code>Badge</code> is now an entity has it has a business existence without <code>Student</code>.  The interesting part is the <code>@JoinColumn</code> annotation that specifies the local column that is the foreign key (<code>STUDENT_ID</code>) as well as to which column of the foreign table its corresponds (<code>ID</code>).</p>

<p>```java Mapping of the Badge entity
@Entity
@Table(name = "BADGES")
public class Badge implements Serializable {</p>

<pre><code>...

@Id
@Column(name = "ID")
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long mId;

@Column(name = "SECURITY_LEVEL")
private Long mSecurityLevel;

@OneToOne
@JoinColumn(name = "STUDENT_ID", referencedColumnName = "ID")
private Student mStudent;

...
</code></pre>

<p>```</p>

<p>As we want the other side to be aware of the relation (bidirectional), it is required to add the <code>mappedBy</code> attribute to the <code>@OneToOne</code> annotation. This attribute references the (Java) property in the entity that is the owner of the relationship.</p>

<p>```java  Mapping of the Student entity
@Entity
...
public class Student implements Serializable {</p>

<pre><code>...
@Id
@Column(name = "ID")
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long mId;


/** The Student's badge. */
@OneToOne(mappedBy = "mStudent")
private Badge mBadge;
...
</code></pre>

<p>}
```</p>

<p>Using the previous mapping, JPA 2.0 produces the following SQL statements to load the Student object.
```sql
SELECT t0.ID, t1.STUDENT_ID, t1.PICTURE, t0.FIRST_NAME, t0.PHONE_NUMBER,</p>

<pre><code>   t0.BIRTH_DATE, t0.LAST_NAME, t0.NUMBER, t0.CITY, t0.STREET, 
   t0.POSTAL_CODE 
</code></pre>

<p>  FROM STUDENTS t0, PICTURES t1
 WHERE (t1.STUDENT_ID = t0.ID)</p>

<p>SELECT ID, SECURITY_LEVEL, STUDENT_ID
  FROM BADGES
 WHERE (STUDENT_ID = ?)
```</p>

<h2>Conclusion</h2>

<p>JPA 2.0 offers many way to represent one to one relationships. This flexibility allows to handle many different scenarios that may happen when integrating legacy databases. The examples used in this blog are to be found in the <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a> project on <a href="http://code.google.com">Google code hosting</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing JPA 2.0 entities in Java SE]]></title>
    <link href="http://hostettler.github.io/blog/2012/03/19/testing-jpa-in-java-se/"/>
    <updated>2012-03-19T13:40:00+01:00</updated>
    <id>http://hostettler.github.io/blog/2012/03/19/testing-jpa-in-java-se</id>
    <content type="html"><![CDATA[<p>Testing JPA components in Java SE has been greatly simplified since JEE6.
Nevertheless, it is still not as simple as testing other components.
Although there exist some frameworks such as <a href="http://www.jboss.org/arquillian">Arquillian</a> that solve that problematic,
it is sometimes to much of hammer to test a couple of entities and simple services.
Here is a post in which I digest some other posts and my own experience of how to test JPA components. The following example is part
of a Demo project I use to teach the JEE stack that is located on Google Code Hosting and <a href="http://code.google.com/p/jee6-demo/">JEE-6-Demo</a>
This project relies on <a href="http://maven.apache.org/">Maven 3</a> for build and dependency management. It does not use EJBs (at least for now) and thus it can be deployed in a Servlet engine.
Please note, that to me the kind of tests we are doing here are not unit tests (though we use JUnit ). Actually, as a database is required,
these  are integration tests.</p>

<p>Let us assume that we want to test that the following model has been properly annotated and can be persisted according to a given DB schema:
``` java An annotated entity that represent a student
// Get the entity manager for the tests.
@Entity
@Table(name = "STUDENTS")
public class Student implements Serializable {</p>

<pre><code>private static final long serialVersionUID = -6146935825517747043L;

@Id
@Column(name = "ID")
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long mId;

@Column(name = "LAST_NAME", length = 35)
private String mLastName;

@Column(name = "FIRST_NAME", nullable = false, length = 35)
private String mFirstName;

@Column(name = "BIRTH_DATE", nullable = false)
@Temporal(TemporalType.DATE)
private Date mBirthDate;
</code></pre>

<p>}
<code>
with the following persistence unit:
</code>
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;persistence version="1.0"</p>

<pre><code>xmlns="http://java.sun.com/xml/ns/persistence"&gt;
&lt;persistence-unit name="JEE6Demo-Persistence"
    transaction-type="RESOURCE_LOCAL"&gt;
    &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;
    &lt;class&gt;ch.demo.dom.Student&lt;/class&gt;
    &lt;properties&gt;
        &lt;property name="eclipselink.target-database" value="MYSQL" /&gt;
        &lt;property name="javax.persistence.jdbc.driver" value="com.mysql.jdbc.Driver" /&gt;
        &lt;property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/Students_DB" /&gt;
        &lt;property name="javax.persistence.jdbc.user" value="root" /&gt;
        &lt;property name="javax.persistence.jdbc.password" value="" /&gt;           
        &lt;property name="eclipselink.ddl-generation" value="none" /&gt;
        &lt;property name="eclipselink.logging.level" value="INFO" /&gt;
    &lt;/properties&gt;
&lt;/persistence-unit&gt;
</code></pre>

<p></persistence>
```</p>

<p>We use <a href="http://www.eclipse.org/eclipselink/">Eclipse-link</a> as it is the reference implementation for JPA 2.0
```xml Eclipse-Link dependencies</p>

<pre><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;EclipseLink Repo&lt;/id&gt;
        &lt;name&gt;EclipseLink Repository&lt;/name&gt;
        &lt;url&gt;http://download.eclipse.org/rt/eclipselink/maven.repo&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;
        &lt;artifactId&gt;eclipselink&lt;/artifactId&gt;
        &lt;version&gt;2.0.0&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.eclipse.persistence&lt;/groupId&gt;
        &lt;artifactId&gt;javax.persistence&lt;/artifactId&gt;
        &lt;version&gt;2.0.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>```</p>

<p>Since JEE 6, it is easy to start the JPA manager in a unit test. Let us look at the following listing. The first two lines initialize the persistence manager given a persistence unit. The name of the persistence unit must matched the declared persistence unit in <code>META-INF/persistence</code>. After what, the try block gets a transaction and starts it. The object student is persisted and the transaction is committed. If anything goes wrong, the transaction is roll-backed. Finally, the entity manager and the factory are closed.
``` java Start the JPA manager manually
// Get the entity manager for the tests.
EntityManagerFactory emf = Persistence.createEntityManagerFactory("JEE6Demo-Persistence");
EntityManager em = emf.createEntityManager();
try {
   //Get a new transaction
   EntityTransaction trx = em.getTransaction();</p>

<p>   //Start the transaction
   trx.begin();
   //Persist the object in the DB
   em.persist(student);
   //Commit and end the transaction
   trx.commit();
} catch (RuntimeException e) {
   if (trx != null &amp;&amp; trx.isActive()) {</p>

<pre><code>  trx.rollback();
</code></pre>

<p>   }
   throw e;
} finally {
   //Close the manager
   em.close();
   emf.close();
}
```</p>

<p>There are several open issues problems with this code:</p>

<ol>
<li>We do want to use a local in memory database. Indeed, we do not want to mess up with the information stored on the Mysql database. Finally, we need the test to be as autonomous as possible. That is that it does not depend on an external server (e.g. app server, database server).</li>
<li>JUnit does not guarantee the order in which the tests are ran.
Therefore, we must initialize the manager before each and every test of the fixture. Furthermore we must close it after the test to
avoid session leaks.</li>
<li>During tests, we must make sure that the database is in an acceptable state before running each unit.</li>
</ol>


<p>To limit the dependencies to other components and to keep the setting simple, we will use <a href="http://db.apache.org/derby/">Derby</a> as a pure in
memory database. That is no file produced during the database execution and thus no cleaning afterwards. Please note that is only used for testing purposes.</p>

<p>```xml Derby in memory database dependencies
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.derby&lt;/groupId&gt;
&lt;artifactId&gt;derby&lt;/artifactId&gt;
&lt;version&gt;10.8.2.2&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency> <br/>
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.derby&lt;/groupId&gt;
&lt;artifactId&gt;derbyclient&lt;/artifactId&gt;
&lt;version&gt;10.8.2.2&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
</code></pre>

<p></dependency>
```</p>

<p>The following <code>persistence.xml</code> file sets  <code>DERBY</code> as a target database language. Using Derby, selecting the embedded
drivers in conjunction <code>org.apache.derby.jdbc.EmbeddedDriver</code> with a <code>jdbc:derby:memory</code> URL runs a database in memory without
persisting anything to disk. This combination is important as it otherwise will store file on the disk.
The following will be used by <code>Maven</code> during the test because it overrides the one in `/main/resources/META-INF/``. This is an elegant way to use a different database setting for the unit tests.
``` xml Persistence descriptor /test/resources/META-INF/persistence.xml
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;persistence version="1.0"</p>

<pre><code>xmlns="http://java.sun.com/xml/ns/persistence"&gt;
&lt;persistence-unit name="JEE6Demo-Persistence"
    transaction-type="RESOURCE_LOCAL"&gt;
    &lt;provider&gt;org.eclipse.persistence.jpa.PersistenceProvider&lt;/provider&gt;
    &lt;class&gt;ch.demo.dom.Student&lt;/class&gt;
    &lt;properties&gt;
        &lt;property name="eclipselink.logging.level" value="FINE" /&gt;
        &lt;property name="eclipselink.target-database" value="DERBY" /&gt;
        &lt;property name="javax.persistence.jdbc.driver" value="org.apache.derby.jdbc.EmbeddedDriver" /&gt;
        &lt;property name="javax.persistence.jdbc.url" value="jdbc:derby:memory:StudentsDB;create=true" /&gt;
        &lt;property name="javax.persistence.jdbc.user" value="" /&gt;
        &lt;property name="javax.persistence.jdbc.password" value="" /&gt;
        &lt;property name="eclipselink.logging.level" value="INFO" /&gt;
    &lt;/properties&gt;        
&lt;/persistence-unit&gt;
</code></pre>

<p></persistence>
```</p>

<p>To solve the second issue, we must guarantee that each test fixture gets a fresh entity manager. JUnit 4+ executes whatever
public static method annotated with <code>@BeforeClass</code> before firing up the class constructor. Similarly, methods annotated with <code>@AfterClass</code>
are executed after all the tests and is therefore a good place for cleanup.
``` java Start the JPA manager before for each test fixture</p>

<p>/<strong> The factory that produces entity manager. */
private static EntityManagerFactory mEmf;
/</strong> The entity manager that persists and queries the DB. */
private static EntityManager mEntityManager;</p>

<p>@BeforeClass
public static void initTestFixture() throws Exception {</p>

<pre><code>// Get the entity manager for the tests.
mEmf = Persistence.createEntityManagerFactory(mPersistenceUnit);
mEntityManager = mEmf.createEntityManager();
...
</code></pre>

<p>}</p>

<p> /<em>*
 * Cleans up the session.
 </em>/
@AfterClass
public static void closeTestFixture() {</p>

<pre><code>mEntityManager.close();
mEmf.close();
</code></pre>

<p>}
```</p>

<p>The problem with the pure in-memory approach is that schema has to recreated for each run. One solution would be to rely on the <code>Eclipse-link</code> DDL creation. I do not really like this solution as it usually not accepted by the customers that tend to want to have control
of their schema. Thus, to have a test setting that is as close as possible to the production setting we need something to install the schema
by running a SQL file. There are many solutions out there:</p>

<ul>
<li>Manually parsing the SQL file. I do not like this solution as it becomes rapidly intractable when the file contains comments and transactions.</li>
<li>Using tools such as <a href="http://www.liquibase.org/">Liquibase</a>. Nice solution but to me it was to much of a hammer to that specific case.</li>
<li>Using an API that does it for me.</li>
</ul>


<p>I propose the last approach by using <code>Derby Tools</code> and in particular the API of <code>ij</code>.
```xml DBUnit dependency
<dependency></p>

<pre><code>&lt;groupId&gt;org.apache.derby&lt;/groupId&gt;
&lt;artifactId&gt;derbytools&lt;/artifactId&gt;
&lt;version&gt;10.8.2.2&lt;/version&gt;
</code></pre>

<p></dependency>
```</p>

<p>This allows to use <code>ij</code> directly in the test to parse the DDL file. This is shown in the following listing.
First, it gets the underlying JDBC connection and then it run the file located in <code>test/resources/sql/</code>.</p>

<p>```java
@BeforeClass
public static void initTestFixture() throws Exception {</p>

<pre><code>// Get the entity manager for the tests.
mEmf = Persistence.createEntityManagerFactory(mPersistenceUnit);
mEntityManager = mEmf.createEntityManager();

Connection connection = ((EntityManagerImpl) (mEntityManager
        .getDelegate())).getServerSession().getAccessor()
        .getConnection();

ij.runScript(connection,
        AbstractDBTest.class.getResourceAsStream("sql/studentSchema.ddl"),
        "UTF-8", System.out, "UTF-8");
</code></pre>

<p>}
```</p>

<p>The third item asks for a way to properly initialize the data prior to the test. Remember that your tests should not rely on the success of
previous ones. To that end, we cleanup the data prior any test execution. A rather easy way to do that is to use
<a href="http://www.dbunit.org/">DBUnit</a>.</p>

<p>```xml DBUnit dependency</p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.dbunit&lt;/groupId&gt;
    &lt;artifactId&gt;dbunit&lt;/artifactId&gt;
    &lt;version&gt;2.4.8&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>

<p><code>
It loads a file named `/test/resources/students-datasets.xml`` from the test resources.
</code>java Initialize the test dataset</p>

<pre><code>@BeforeClass
public static void initTestFixture() throws Exception {
// Get the entity manager for the tests.
mEmf = Persistence.createEntityManagerFactory(mPersistenceUnit);
mEntityManager = mEmf.createEntityManager();

Connection connection = ((EntityManagerImpl) (mEntityManager
        .getDelegate())).getServerSession().getAccessor()
        .getConnection();

ij.runScript(connection,
        AbstractDBTest.class.getResourceAsStream("sql/studentSchema.ddl"),
        "UTF-8", System.out, "UTF-8");

    mDBUnitConnection = new DatabaseConnection(connection);
    //Loads the data set from a file named students-datasets.xml
    mDataset = new FlatXmlDataSetBuilder().build(Thread.currentThread()
            .getContextClassLoader()
            .getResourceAsStream("students-datasets.xml"));

    ...
}
</code></pre>

<p>```</p>

<p>After what, clean test data are inserted for each and every test of the fixture:</p>

<p>```java init of the test</p>

<pre><code>@Before
public void initTest() throws Exception {
    //Clean the data from previous test and insert new data test.
    DatabaseOperation.CLEAN_INSERT.execute(mDBUnitConnection, mDataset);
}
</code></pre>

<p>```</p>

<p>In this post, I've showed how to test the persistence of an JPA 2.0 entity using JUnit 4. The test setting runs in memory without external server  and enforces a clean database state prior running the tests.</p>

<p>To support my teaching activities on Java EE 6, I've setup a project on Google Code Hosting that contains all the presented sources and much more. Please give me feedbacks on how to improve that demo project and in particular its
testability.</p>
]]></content>
  </entry>
  
</feed>
